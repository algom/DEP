---
title: "proteomeR package"
author: "Arne Smits"
date: "`r doc_date()`"
package: "`r pkg_ver('proteomeR')`"
vignette: >
  %\VignetteIndexEntry{proteomeR package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
output:
  BiocStyle::html_document
---

```{r required packages, echo = FALSE, warning=FALSE, results="hide"}
suppressPackageStartupMessages({library(BiocStyle)
library(tidyverse)
library(magrittr)
library(proteomeR)
})
```

# Overview of the analysis

This analysis workflow provides an integrated solution for robust and reproducible differential analysis (protein expression or protein enrichment) of proteomics data. It requires tabular input (e.g. txt files) which are generated by quantitative analysis softwares of raw mass spectrometry data, such as [MaxQuant](http://www.nature.com/nbt/journal/v26/n12/full/nbt.1511.html) or [IsobarQuant](http://www.nature.com/nprot/journal/v10/n10/full/nprot.2015.101.html).  
Functions are provided for data preparation, data filtering, variance normalization and imputation of missing values, as well as statistical testing of differential enriched/expressed proteins. It also includes tools to check intermediate steps within the workflow, such as normalization and missing values imputation. Finally, visualization tools are provided to explore the results, including heatmap, volcano plot and barplot representations. Besides differential analysis, the package includes a set of functions to calculate relative stoichiometry, as originally desribed in [Smits et al (2013)](http://nar.oxfordjournals.org/content/41/1/e28.full).   
For scientists with limited experience in R, the package also entails wrapper functions that entail the complete analysis workflow and generate a report (see the chapter on [Wrapper functions](#wrapper-functions-for-the-entire-workflow)). Even easier to use are the interactive Shiny apps that are provided by the package (see the chapter on [Shiny apps](#interactive-analysis-using-the-proteomer-shiny-apps)).

# Installation

Install and load the package
```{r install, eval = FALSE}

devtools::install_git("git@git.embl.de:smits/proteomeR.git")
library("proteomeR")

```

# Interactive analysis using the proteomeR Shiny apps

The package contains two `r CRANpkg("shiny") ` apps, which allow for interactive analysis entailing the entire workflow described below.
These are especially relevant for users with limited or no experience in R.
Currently, there are three different apps. One for label-free quantification (LFQ)-based analysis (output from MaxQuant) and the second for tandem-mass-tags (TMT)-based analysis (output from IsobarQuant). The third app, is a extention of the LFQ-based analysis for iBAQ-based stoichiometry analysis.
To run the apps, simply run this single command:

``` {r run_app, eval = FALSE}
# For LFQ analysis
run_app("LFQ")

# For TMT analysis
run_app("TMT")

# For iBAQ-based stoichiometry analysis
run_app("iBAQ")
```

# Differential analysis

## Example dataset for differential enrichment analysis: Ubiquitin interactors

We analyze a proteomics dataset in which Ubiquitin-protein interactors were characterized ([Zhang et al. Mol Cell 2017](http://www.cell.com/molecular-cell/fulltext/S1097-2765(17)30004-7)).
The raw mass spectrometry data were first analyzed using MaxQuant ([Cox and Mann, Nat Biotech 2007](http://www.nature.com/nbt/journal/v26/n12/full/nbt.1511.html)).

## Loading of the data

```{r load data}
# Loading two packages required for data handling
library(tidyverse)
library(magrittr)

# The data is provided with the package
data <- UbiLength

# We filter for contaminant proteins and decoy database hits, which are indicated by "+"
# in the columns "Potential.contaminants" and "Reverse", respectively. 
data %<>% filter(Reverse != "+", Potential.contaminant != "+")
```


The data.frame has the following dimensions:

``` {r dimension}
dim(data)
```

The data.frame has the following column names:

``` {r colnames}
colnames(data)
```

The "LFQ.intensity" columns will be used for subsequent analysis.

## Data preparation

The dataset has unique Uniprot identifiers, however those are not immediately informative.
The associated gene names are informative, however these are not always unique.

``` {r unique}
# Are there any duplicated gene names?
data$Gene.names %>% duplicated(.) %>% any(.)

# Make a table of duplicated gene names
data %>% group_by(Gene.names) %>% summarize(frequency = n()) %>% 
  arrange(desc(frequency)) %>% filter(frequency > 1)
```

For further analysis these proteins must get unique names.
Additionally, some proteins do not have an annotated gene name and for those we will use the Uniprot ID.

``` {r unique_names}
# Make unique names using the annotation in the "Gene.names" column as primary names
# and the annotation in "Protein.IDs" as name for those that do not have an gene name.
data_unique <- unique_names(data, "Gene.names", "Protein.IDs", delim = ";")

# Are there any duplicated names?
data$name %>% duplicated(.) %>% any(.)
```

## Generate an SummarizedExperiment object

Many [Bioconductor](http://www.bioconductor.org/) packages use SummarizedExperiment objects as input and/or output.
This class of objects contains and coordinates the actual (assay) data, information on the samples as well as feature annotation.
We can generate the SummarizedExperiment object from our data using two different approaches.
We can extract sample information directly from the column names or we add sample information using an experimental design template.
For our example dataset, an experimental design is included in the package.

``` {r expdesign, echo = FALSE}
# Display experimental design
knitr::kable(UbiLength_ExpDesign)
```

``` {r to_exprset}
# Generate an SummarizedExperiment object with an experimental design
LFQ_columns <- grep("LFQ.", colnames(data_unique)) # get LFQ column numbers
experimental_design <- UbiLength_ExpDesign
data_se <- make_se(data_unique, LFQ_columns, experimental_design)

# Generate an SummarizedExperiment object by parsing condition information from the column names
LFQ_columns <- grep("LFQ.", colnames(data_unique)) # get LFQ column numbers
data_se_parsed <- make_se_parse(data_unique, LFQ_columns)

# Let's have a look at the SummarizedExperiment object
data_se

```

## Filter for missing values

The dataset contains proteins which are not quantified in all replicates. Some proteins are even only deteced in a single replicate.
This leaves our dataset with missing values, which need to be imputed. However, this should not be done for proteins that contain too many missing values.
Therefore, we first filter out proteins that contain to many missing values. This is done by setting the threshold for the allowed number of missing values per condition in the _filter_missval_ function.

``` {r filter_missval}
# Filter for proteins that are identified in all replicates of at least one condition
data_filt <- filter_missval(data_se, thr = 0)

# Less stringent filtering:
# Filter for proteins that are identified in 2 out of 3 replicates of at least one condition
data_filt2 <- filter_missval(data_se, thr = 1)
```

After filtering the number of identified proteins per sample can be plotted as well as the overlap in identifications between samples.

``` {r plot_data, , fig.width = 4, fig.height = 4}
# Plot a barplot of the number of identified proteins per samples
plot_numbers(data_filt)
# Plot a barplot of the protein identification overlap between samples
plot_coverage(data_filt)
# Plot a barplot of the protein identification overlap between samples
plot_frequency(data_filt)
```

## Normalization

The data is background corrected and normalized by variance stabilization transformation (`r Biocpkg("vsn") `). 

``` {r normalize}
# Normalize the data
data_norm <- norm_vsn(data_filt)
```

The normalization can be inspected by checking the distributions of the samples before and after normalization.

``` {r plot_norm, fig.height = 6}
# Visualize normalization by boxplots for all samples before and after normalization
plot_norm(data_filt, data_norm)
```

## Imputate data for missing values

The remaining missing values in the dataset need to be imputed.
The data can be missing at random (MAR), for example if proteins are quantified in some replicates but not in others,
or missing not at random (MNAR), for example if proteins which are quantified in some replicates but not in others (e.g. in all replicates of the control).
MNAR can indicate that the proteins are below the detection limit in specific samples, which could be very well the case for, for example, affinity enrichments.
For these different conditions, different imputation methods have to be used, as described in the `r Biocpkg("MSnbase") ` vignette and more specifically in the _impute_ function descriptions.  

First, the missingness pattern of the data is explored by plotting a heatmap indicating whether values are missing (0) or not (1).

``` {r plot_missval, fig.height = 6, fig.width = 5}
# Plot a heatmap of proteins with missing values
plot_missval(data_filt)
```

The example dataset is an affinity enrichment dataset of ubiquitin interactors, which is likely to have proteins which are below the detection limit in specific samples.
These can be proteins that are specifically enriched in the ubiquitin purifications, but are not enriched in the controls samples, or vice versa.
This expectation is also reflected in the missingness heatmap; missing values are highly biased to specific samples.
To check whether missing values are biased to lower intense proteins, we visualize the densities and cumulative sums of proteins with and without missing values.   

``` {r plot_detect, fig.height = 6, fig.width = 6}
# Plot intensity distributions and cumulative fraction 
# of proteins with and without missing values
plot_detect(data_filt)
```

The imputation method to be used depends on the missingness pattern of the data (see the `r Biocpkg("MSnbase") ` vignette and more specifically the _impute_ function description for more information).
Values which are missing not at random (MNAR) should be imputed by left-censored imputation method, such as the quantile regression-based left-consored function ("QRILC") or random draws from a left-shifted distribution "(MinProb"). In contrast, data missing at random (MAR) should be imputed with methods such as k-nearest neighbour ("knn") or maximum likelihood ("MLE") functions.  

As the example data has left-censored missing values (missing not at random), 'MinProb' or 'QRILC' imputation are appropriate imputation methods.

``` {r impute, results = "hide", message = FALSE, warning = FALSE}
# Impute missing data using random draws from a Gaussian distribution centered around 
# a minimal value (for data not missing at random)
data_imp <- imputation(data_norm, fun = "MinProb", q = 0.01)

# Impute missing data using the quantile regression-based left-censored 
# imputation method (QRILC) (for data not missing at random)
data_imp_QRILC <- imputation(data_norm, fun = "QRILC")

# Impute missing data using radom drwas from a manually defined 
# left-shifted Gaussian distribution (for data not missing at random)
data_imp_man <- imputation(data_norm, fun = "man", shift = 1.8, scale = 0.3)

# Impute missing data using the k-nearest neighbour approach
# (for data missing at random)
data_imp_knn <- imputation(data_norm, fun = "knn")

# Impute missing data using the k-nearest neighbour approach
#(for data missing at random)
data_imp_MLE <- imputation(data_norm, fun = "MLE")
```
   
The effect of the imputation on the distributions can be visualized.

``` {r plot_imp, fig.width = 4, fig.height = 4}
# Plot intensity distributions before and after imputation
plot_imp(data_norm, data_imp)
```

## Differential enrichment analysis

Linear models combined with empherical Bayes statistics is used for the analysis of differential enrichment (or differential expression for analysis on expression levels).
The _linear_model_ wrapper function introduced here uses `r Biocpkg("limma") ` and automatically generates the contrasts to be tested.
For the contrasts generation, the control sample has to be specified.
Additionally, the types of contrasts to be produced need to be indicated, allowing the generation of all possible comparisons ("all") or the generation of contrasts of every sample versus control ("control").

``` {r statistics}
# Differential enrichment analysis  based on linear models and empherical Bayes statistics
# Test every sample versus control
data_lm <- linear_model(data_imp, control = "Ctrl", type = "control")

# Test all possible comparisons of samples
data_lm_all_contrasts <- linear_model(data_imp_QRILC, control = "Ctrl", type = "all")
```

An ANOVA and post-hoc Tukey Honest Significant Differences analysis is also implemented, although the use of _linear_models_ based on `r Biocpkg("limma") ` is recommended.

``` {r statistics2, , results = "hide", message = FALSE}
# Differential enrichment analysis  based on ANOVA and Tukey
data_anova <- anova_tukey(data_imp, control = "Ctrl", type = "control")

```

Finally, significant proteins are defined by user-defined cutoffs.

``` {r results}
# Denote significant proteins based on user defined cutoffs
data_sign <- cutoffs(data_lm, alpha = 0.05, lfc = log2(1.5))

# Number of significant proteins
results(data_sign) %>% filter(sign == "+") %>% nrow()

```

## Visualization of the results

The data resulting from the previous analysis can easily be visualized by a number of functions.
These visualizations assist in the determination of the optimal cutoffs to be used, highlight the most interesting samples and contrasts, and pinpoint differentially enriched/expressed proteins.

### Heatmap of all significant proteins

The heatmap representation gives an overview of all significant proteins (rows) in all samples (columns).
This allows to see general trends, e.g. one sample really different or one replicate which is off in all samples.
Additionally, the clustering of samples (columns) can indicate closer related samples and clustering of proteins (rows) indicates similarly behaving proteins. The proteins are additionally clustered by k-means clustering and the number of clusters can be defined by k.

``` {r heatmap, fig.height = 8, fig.width = 4}
# Plot a heatmap of all significant proteins with the data centered per protein
plot_heatmap(data_sign, type = "centered", k = 6, col_limit = 4, labelsize = 3)
```

The heatmap shows a really nice clustering of the replicates and indicates that 4Ubi and 6Ubi enrich a similar repetoire of proteins. The k-means clustering of proteins (general clusters of rows) nicely separates protein classes with different binding behaviours.  

***

Alternatively, a heatmap can be plotted with the direct sample comparisons (columns) for all significant proteins (rows). In this example this emphasises the enrichment of ubiquitin interactors over the control sample.

``` {r heatmap2, fig.height = 8, fig.width = 4}
# Plot a heatmap of all significant proteins (rows) and the tested contrasts (columns)
plot_heatmap(data_sign, type = "contrast", k = 6, col_limit = 10, labelsize = 3)
```

### Volcano plots of specific contrasts

Volcano plots can be used to visualize a specific contrast (comparison between two samples). This allows to inspect the enrichment of proteins between the two samples (x axis) and their corresponding adjusted p value (y axis).

``` {r volcano, fig.height = 5, fig.width = 6}
# Plot a volcano plot for the contrast "Ubi6 vs Ctrl""
plot_volcano(data_sign, contrast = "Ubi6_vs_Ctrl", labelsize = 2)
# Plot a volcano plot for the contrast "Ubi6 vs Ctrl"" without labels
plot_volcano(data_sign, contrast = "Ubi6_vs_Ctrl", add_names = FALSE)
```

### Barplots of a protein of interest

It can also be useful to plot the data of a single protein, for example if this protein is of special interest.

``` {r bar, fig.height = 3.5, fig.width = 3.5}
# Plot a barplot for the protein USP15 with the data centered
plot_single(data_sign, protein = "USP15", type = "centered")

# Plot a barplot for the protein USP15
plot_single(data_sign, protein = "USP15", type = "contrast")
```

## Results table

To extract a table containing the essential results, the _results_ function can be used.

``` {r results_table}
# Generate a results table
data_results <- results(data_sign)
```

The resulting table contains the following columns:

``` {r results_table2}
# Column names of the results table
colnames(data_results)
```

Of these columns, the __p.adj__ columns contain the adjusted p values for the contrast as depicted in the column name. The __ratio__ columns contain the average log2 fold changes. The __sign__ columns indicate whether the protein is differentially enriched/expressed, as defined by the chosen cutoffs. The __centered__ columns contain the average log2 enrichment values scaled by protein-wise centering.

# Stoichiometry analysis

## Example dataset for stoichiometry analysis: PRC2 interactors

We analyze a proteomics dataset in which PRC2 interactors were characterized in Embryonic Stem Cells ([Kloet et al. Nature Structural & Molecular Biology 2016](http://www.nature.com/nsmb/journal/v23/n7/full/nsmb.3248.html)). Again, the raw mass spectrometry data were analyzed using MaxQuant ([Cox and Mann, Nat Biotech 2007](http://www.nature.com/nbt/journal/v26/n12/full/nbt.1511.html)).

## Loading and preparation of the data, and generation of a SummarizedExperiment object

First, the data needs to be prepared for differential analysis.

``` {r GFPip}

# The data is provided with the package
data <- GFPip
expdesign <- GFPip_ExpDesign

# We filter for contaminant proteins and decoy database hits and generate unique names
data %<>% filter(Reverse != "+", Contaminant != "+")
data_unique <- unique_names(data, "Gene.names", "Protein.IDs")

# The SummarizedExperiment object is generated
cols <- grep("LFQ.", colnames(data_unique))
data_se <- make_se(data_unique, cols, expdesign)

```

## Filter on missing values, normalization and imputation

As described in ["differential analysis"](#~differential~analysis), the dataset is filtered on missing values, variance stabilized and remaining missing values are imputed.

``` {r GFPip_filt, fig.width = 4, fig.height = 4}

# Filter for proteins that are identified in all replicates of at least one condition
data_filt <- filter_missval(data_se, thr = 0)

# Plot a barplot of the number of identified proteins per samples
plot_numbers(data_filt)
# Plot a barplot of the protein identification overlap between samples
plot_coverage(data_filt)

# Normalize
data_norm <- norm_vsn(data_filt)

# Visualize normalization
plot_norm(data_filt, data_norm)

# Plot missingness pattern
plot_missval(data_filt)

# Impute left-censored values, as the missingness pattern is not at random
data_imp <- imputation(data_norm, fun = "MinProb", q = 0.01)

```

## Differential enrichment analysis

``` {r GFPip_DE}

# Differential enrichment analysis
data_lm <- linear_model(data_imp, control = "WT", type = "control")

# Call significant proteins based on user defined cutoffs
data_sign <- cutoffs(data_lm, alpha = 0.05, lfc = 4.5)

# Visualize the results
plot_volcano(data_sign, contrast = "GFP_vs_WT")

```

## Stoichiometry analysis

``` {r GFPip_stoi}

# Load peptides data (available in the package)
peptides <- GFPip_pep

# Merge iBAQ values for the proteins with shared peptides
ibaq <- merge_ibaq(data_unique, peptides)

# Calculate stoichiometry
stoi <- stoichiometry(data_sign, ibaq, "GFP_vs_WT", "Suz12")

# Check the stoichiometry values for the ten most abundant proteins
head(stoi)

# Plot stoichiometry
plot_stoi(stoi, thr = 0.01)

```

# Wrapper functions for the entire workflow

The package also entails wrapper functions that entail the complete analysis workflow and generate a report. 

## LFQ analysis

``` {r LFQ}
# The data is provided with the package 
data <- UbiLength
experimental_design <- UbiLength_ExpDesign

# The wrapper function performs the full analysis
data_results <- LFQ(data, experimental_design, fun = "MinProb", 
      control = "Ctrl", type = "control", alpha = 0.05, lfc = 1)
```

This wrapper produces a list of objects, which can be used to create a report and/or for further analysis.
The reports function produces two reports (pdf and html) and a results table, which are saved in a generated "Report" folder.

``` {r report}
# See all objects saved within the results object
names(data_results)

# Make a markdown report and save the results
report(data_results)
```

The results generated by the LFQ function contain, among others, the _results_ object (data.frame object) and the _sign_ object (SummarizedExperiment object).
The _results_ object contains the essential results and the _sign_ object contains the full SummarizedExperiment object which can be used for further visualization.

``` {r LFQ_results}
# Colnames of the results object
colnames(data_results$results)

# the sign object
data_results$sign
```

The results table can be explored by selecting the _$results_ object

``` {r LFQ_results3}
# Extract the results table
results_table <- data_results$results

# Number of significant proteins
results_table %>% filter(sign == "+") %>% nrow()
```

The full data (_sign_ object) can be used for the plotting functions as desribed in the chapter ["Visualization of the results"](#visualization-of-the-results).

``` {r LFQ_results4, fig.height = 5, fig.width = 6}
# Extract the sign object
full_data <- data_results$sign

# Use the full data to generate a volcano plot
plot_volcano(full_data, contrast = "Ubi4_vs_Ctrl", labelsize = 2)
```

``` {r LFQ_results5, fig.height = 3.5, fig.width = 3.5}
# Use the full data to generate a barplot 
plot_single(full_data, protein = "PSMD14", type = "centered")

```

## iBAQ-based stoichiometry analysis

``` {r iBAQ}

# The data is provided with the package 
data <- GFPip
expdesign <- GFPip_ExpDesign

# The LFQ wrapper function performs the full differential analysis
data_results <- LFQ(data, expdesign, fun = "MinProb", 
      control = "WT", type = "control", 
      filter = c("Reverse", "Contaminant"), alpha = 0.05, lfc = 4.5)

# Plot volcano from LFQ results
plot_volcano(data_results$sign, "GFP_vs_WT")

# The iBAQ wrapper function performs the stoichiometry analysis
stoi <- iBAQ(data_results, peptides, "GFP_vs_WT", "Suz12")
head(stoi)

```

## TMT analysis

``` {r TMT, eval = FALSE}
# Need example data
TMTdata <- example_data
Exp_Design <- example_Exp_Design

# The wrapper function performs the full analysis
TMTdata_results <- TMT(data, expdesign = Exp_Design, fun = "QRILC",
    control = "Con_", type = "control", alpha = 0.05, lfc = 1)
```
