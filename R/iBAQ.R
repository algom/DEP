#' Merge iBAQ intensities of protein groups based on shared peptides
#'
#' \code{ibaq_merge} generates a data.frame with iBAQ intensities, which are merged for proteins with shared peptides.
#'
#' @param data Data.frame, Data object with unique names generated by \code{\link{unique_names}}.
#' @param peptides Data.frame, Peptide table from MaxQuant ("peptides.txt").
#' @return A data.frame with iBAQ intensities per protein group from peptides unique to this group
#' @examples
#' data <- GFPip
#' peptides <- GFPip_pep
#'
#' ibaq <- ibaq_merge(data, peptides)
#' colnames(ibaq)
#' head(ibaq)
#' @export
ibaq_merge <- function(data, peptides) {
  # Filter for peptides not unique to a single protein group and sort their protein group IDs
  shared_pep <- peptides %>% filter(Unique..Groups. == "no")
  sorted_pep <- shared_pep %>% select(Protein.group.IDs) %>% mutate(Protein.group.IDs = lapply(Protein.group.IDs, function (x) strsplit(x, ";")[[1]] %>% as.numeric() %>% sort() %>% paste(., collapse = ";")))
  # Expand the protein groups from a single column to a matrix and filter for unique combinations
  max <- lapply(sorted_pep$Protein.group.IDs, function (x) strsplit(x, ";")[[1]] %>% length()) %>% unlist() %>% max()
  shared <- sorted_pep %>% separate(., Protein.group.IDs, paste0("X",1:max), sep = ";",fill = "right")
  shared_filt <- shared %>% mutate(paste = apply(shared, 1, function(x) paste(x[!is.na(x)], collapse = ":"))) %>% filter(!duplicated(paste)) %>% select(-paste)

  # Combine all protein group IDs that have overlapping peptides
  x <- list(shared_filt[1,!is.na(shared_filt[1,])]) # set first IDs group
  for(i in 2:nrow(shared_filt)) {
    ids <- shared_filt[i,!is.na(shared_filt[i,])] # get IDs of new row and check whether they match with any of the previous IDs
    if(any(ids %in% unlist(x))) {
      match <- ids[ids %in% unlist(x)] # Get the IDs that match
      if(length(match) == 1) { rows <- grep(paste("\\b", match, "\\b", sep = ""), x) } # Grep the rows of the single match
      if(length(match) > 1) { rows <- apply(match, 2, function(y) grep(paste("\\b", y, "\\b", sep = ""), x)) %>% unlist() %>% unique() } # Grep the rows of all matches
      if(length(rows) == 1) { x[[rows]] <- unique(unlist(c(unlist(x[[rows]]),ids))) } # Combine the single matched ID group with the current IDs
      if(length(rows) > 1) {
        x[[rows[1]]] <- unique(unlist(c(unlist(lapply(rows, function(y) x[[y]])),ids))) # Combine all matched ID groups and the current IDs in the first matched ID group and remove the others
        for(j in 2:length(rows)) {
          x[[rows[j]-j+2]] <- NULL
        }
      }
    }
    if (!any(ids %in% unlist(x))) {
      x[[(length(x) + 1)]] <- ids # In case there is no match with previous IDs groups, make a new IDs group
    }
  }

  # Function to convert the heterogenous list to a list of data.frames
  list2mat <- function(list) {
    if(is.character(list)) {
      dat <- t(as.data.frame(as.numeric(list)))
    } else {
      dat <- t(as.data.frame(as.numeric(list)))
    }
    colnames(dat) <- paste("X", 1:ncol(dat), sep = "")
    return(dat)
  }

  # Get all shared IDs
  shared_ids <- lapply(x, list2mat) %>% unlist(.)
  # Generate a single data.frame from the list of IDs groups
  rows2merge <- lapply(x, list2mat) %>% lapply(as.data.frame) %>% bind_rows()

  columns <- grep("iBAQ.", colnames(data))
  # Function to merge protein groups with shared peptides
  merge_sum <- function(rows) {
    sub <- data %>% filter(grepl(paste("^", rows, "$", collapse = "|", sep = ""), id))
    sub[1,columns] <- colSums(sub[,columns])
    sub$name[1] <- paste(sort(unique(sub$name)), collapse = ";")
    return(sub[1,] %>% select(name, columns))
  }
  merged <- apply(rows2merge, 1, merge_sum) %>% bind_rows()

  # Select all protein groups that only have peptides unique to this group
  data_unique <- data %>% filter(!id %in% shared_ids)

  # Generate the final list of all protein groups
  final <- rbind(data_unique %>% select(name, columns),merged)

  raw <- final[,2:ncol(final)]
  max <- lapply(final$name, function (x) strsplit(x, ";")[[1]] %>% length()) %>% unlist() %>% max()
  names <- final %>% separate(., name, paste0("name_",1:max), sep = ";",fill = "right", remove = FALSE)
  return(names)
}

#' Relative stoichiometry
#'
#' \code{stoichiometry} calculates relative stoichiometry of proteins
#'
#' @param data SummerizedExperiment, Data object generated by \code{\link{linear_model}} and \code{\link{cutoffs}}.
#' @param ibaq Data.frame, iBAQ object generated by \code{\link{ibaq_merge}}.
#' @param contrast Character, The specific contrast to calculate the stroichiometry for.
#' @param bait Character, The name of the protein to which all other proteins will be scaled for the relative stoichiometry
#' @param level Numerical, The level to which the bait will be scaled
#' @return A data.frame with relative stoichiometry values per protein
#' @examples
#' # load data
#' data <- GFPip
#' exp_design <- GFPip_ExpDesign
#' peptides <- GFPip_pep
#'
#' # Make unique names and filter for reverse and contaminant hits
#' data_unique <- data %>% unique_names(., "Gene.names", "Protein.IDs")
#' data_filt <- data_unique %>% filter(Reverse != "+", Contaminant != "+")
#'
#' # Make a SummarizedExperiment and perform filtering on missing values, variance stabilization and imputation on this object
#' cols <- grep("LFQ", colnames(data_filt))
#' se <- make_se(data_filt, cols, exp_design)
#' filt <- filter_missval(se)
#' norm <- norm_vsn(filt)
#' imp <- imputation(norm, "MinProb")
#'
#' # Test for differential enriched proteins
#' lm <- linear_model(imp, "WT", "control")
#' sign <- cutoffs(lm, alpha = 0.05, lfc = 4.5)
#'
#' # Make a results table and check number of differential enrich proteins
#' results <- results(sign)
#' results %>% filter(sign == "+") %>% nrow()
#'
#' # Merge iBAQ intensities of proteins that have shared peptides
#' ibaq <- ibaq_merge(data_unique, peptides)
#'
#' # Calculate relative stoichiometry versus "Suz12" in the "GFP_vs_WT" contrast
#' stoi <- stoichiometry(sign, ibaq, contrast = "GFP_vs_WT", bait = "Suz12")
#'
#' @export
stoichiometry <- function(data, ibaq, contrast, bait, level = 1) {
  row_data <- rowData(data)

  # Show error if an unvalid contrast is given
  if(length(grep(paste(contrast, "_diff", sep = ""), colnames(row_data))) == 0) {
    valid_cntrsts <- row_data %>% data.frame() %>% select(ends_with("_diff")) %>% colnames(.) %>% gsub("_diff", "", .)
    valid_cntrsts_msg <- paste0("Valid contrasts are: '", paste0(valid_cntrsts, collapse = "', '"), "'")
    stop(
      "Not a valid contrast, please run `plot_volcano()` with a valid contrast as argument\n",
      valid_cntrsts_msg,
      call. = FALSE)
  }

  col_sign <- grep(paste(contrast, "_sign", sep = ""), colnames(row_data)) # All significance columns
  row_data <- row_data[row_data[,col_sign] == "+", ]
  names <- row_data$name
  rows <- ibaq %>% select(starts_with("name_")) %>% apply(., 2, function(x) grep(paste("^", names, "$", sep = "", collapse = "|"), x)) %>% unlist() %>% unique()
  sub <- ibaq[rows,] %>% select(name, starts_with("iBAQ."))

  ip <- gsub("_vs_.*", "", contrast)
  control <- gsub(".*_vs_", "", contrast)
  ibaq_anno <- colData(data) %>% data.frame() %>% mutate(sample = paste("iBAQ.", label, sep = ""))
  long <- sub %>% gather(sample, iBAQ, 2:ncol(.)) %>% left_join(., ibaq_anno, by = "sample")

  ctrl <- long %>% group_by(name, condition) %>% summarise(mean_ctrl = mean(iBAQ)) %>% filter(condition == control) %>% select(name, mean_ctrl)
  stoi <- long %>% left_join(., ctrl, by = "name") %>% filter(condition == ip) %>% mutate(iBAQ = iBAQ - mean_ctrl)
  wide <- stoi %>% select(name, iBAQ, ID) %>% spread(ID, iBAQ)

  # Show error if an unvalid bait is given
  if(length(grep(paste("^", bait, "$", sep = ""), wide$name)) == 0) {
    valid_baits_msg <- paste0("Valid baits are: '", paste0(wide$name, collapse = "', '"), "'")
    stop(
      "Not a valid bait, please run `stoichiometry()` with a valid bait as argument\n",
      valid_baits_msg,
      call. = FALSE)
  }

  num <- wide %>% filter(name == bait) %>%  .[,2:ncol(.)]
  num <- num / level
  final <- wide %>% mutate_each(funs(. / num$.), 2:ncol(.)) %>% gather(ID, iBAQ, 2:ncol(.)) %>% left_join(., ibaq_anno, by = "ID")
  return(final)
}

#' Plot the relative stoichiometry
#'
#' \code{plot_stoi} plots a barplot of the relative stoichiometries of all proteins.
#'
#' @param data Data.frame, Stoichiometry object generated by \code{\link{stoichiometry}}.
#' @param thr Numerical, The stoichiometry threshold above which proteins will be plotted.
#' @param max_y Numerical, The maximum scale of the y-axis.
#' @return A barplot
#' @examples
#' #' # load data
#' data <- GFPip
#' exp_design <- GFPip_ExpDesign
#' peptides <- GFPip_pep
#'
#' # Make unique names and filter for reverse and contaminant hits
#' data_unique <- data %>% unique_names(., "Gene.names", "Protein.IDs")
#' data_filt <- data_unique %>% filter(Reverse != "+", Contaminant != "+")
#'
#' # Make a SummarizedExperiment and perform filtering on missing values, variance stabilization and imputation on this object
#' cols <- grep("LFQ", colnames(data_filt))
#' se <- make_se(data_filt, cols, exp_design)
#' filt <- filter_missval(se)
#' norm <- norm_vsn(filt)
#' imp <- imputation(norm, "MinProb")
#'
#' # Test for differential enriched proteins
#' lm <- linear_model(imp, "WT", "control")
#' sign <- cutoffs(lm, alpha = 0.05, lfc = 4.5)
#'
#' # Make a results table and check number of differential enrich proteins
#' results <- results(sign)
#' results %>% filter(sign == "+") %>% nrow()
#'
#' # Merge iBAQ intensities of proteins that have shared peptides
#' ibaq <- ibaq_merge(data_unique, peptides)
#'
#' # Calculate relative stoichiometry versus "Suz12" in the "GFP_vs_WT" contrast
#' stoi <- stoichiometry(sign, ibaq, contrast = "GFP_vs_WT", bait = "Suz12")
#' plot_stoi(stoi)
#'
#' @export
plot_stoi <- function(data, thr = 0.01, max_y = NULL) {
  df <- data %>% group_by(name, condition) %>% summarize(mean = mean(iBAQ), sd = sd(iBAQ)) %>% arrange(desc(mean)) %>% filter(mean >= thr) %>% ungroup(name)
  df %<>% mutate(name = ifelse(nchar(name) > 20, paste(substr(name, 1, 20), "...", sep = ""), name), ymin = mean - sd, ymax = mean + sd)
  df$name <- parse_factor(df$name, levels = unique(df$name))
  if(is.null(max_y)) {max <- max(df$ymax)} else { max <- max_y}
  bait <- df %>% filter(mean == 1) %>% .$name %>% unique()
  ggplot(df, aes(x = name, y = mean)) + geom_bar(stat = "identity") + geom_errorbar(aes(ymax = ymax, ymin = ymin), width = 0.2) + theme_bw() + labs(title = unique(df$condition), x = "", y = paste("Stoichiometry (vs ", bait, ")", sep ="")) + ylim(0,max) +
      theme(axis.text=element_text(size=12), axis.text.x = element_text(angle = 90, hjust = 1, size = 8), axis.title=element_text(size=14,face="bold"), legend.text=element_text(size=12), legend.title = element_text(size=14,face="bold"), legend.position="right")
}

#' Relative stoichiometry results table
#'
#' \code{results_stoi} generates a results table of relative stoichiometry values.
#'
#' @param data Data.frame, Stoichiometry object generated by \code{\link{stoichiometry}}.
#' @param thr Numerical, The stoichiometry threshold above which proteins will be plotted.
#' @return A data.frame with the stoichiometry information
#' @examples
#' # load data
#' data <- GFPip
#' exp_design <- GFPip_ExpDesign
#' peptides <- GFPip_pep
#'
#' # Make unique names and filter for reverse and contaminant hits
#' data_unique <- data %>% unique_names(., "Gene.names", "Protein.IDs")
#' data_filt <- data_unique %>% filter(Reverse != "+", Contaminant != "+")
#'
#' # Make a SummarizedExperiment and perform filtering on missing values, variance stabilization and imputation on this object
#' cols <- grep("LFQ", colnames(data_filt))
#' se <- make_se(data_filt, cols, exp_design)
#' filt <- filter_missval(se)
#' norm <- norm_vsn(filt)
#' imp <- imputation(norm, "MinProb")
#'
#' # Test for differential enriched proteins
#' lm <- linear_model(imp, "WT", "control")
#' sign <- cutoffs(lm, alpha = 0.05, lfc = 4.5)
#'
#' # Make a results table and check number of differential enrich proteins
#' results <- results(sign)
#' results %>% filter(sign == "+") %>% nrow()
#'
#' # Merge iBAQ intensities of proteins that have shared peptides
#' ibaq <- ibaq_merge(data_unique, peptides)
#'
#' # Calculate relative stoichiometry versus "Suz12" in the "GFP_vs_WT" contrast
#' stoi <- stoichiometry(sign, ibaq, contrast = "GFP_vs_WT", bait = "Suz12")
#' plot_stoi(stoi)
#' results_stoi(stoi)
#'
#' @export
results_stoi <- function(data, thr = 0.01) {
  df <- data %>% group_by(name, condition) %>% summarize(mean = mean(iBAQ), sd = sd(iBAQ)) %>% arrange(desc(mean)) %>% filter(mean >= thr) %>% ungroup(name)
  df %<>% mutate(ymin = mean - sd, ymax = mean + sd)
  df$name <- parse_factor(df$name, levels = unique(df$name))
  df %>% select(-condition, -ymax, -ymin) %>% data.frame()
}
