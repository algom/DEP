#' Merge iBAQ intensities of protein groups based on shared peptides
#'
#' \code{ibaq_merge} generates a volcano plot for a specified contrast.
#'
#' @param data SummerizedExperiment, Data object with unique names generated by \code{\link{unique_names}}.
#' @param peptides Data.frame, Peptide table from MaxQuant ("peptides.txt").
#' @return A data.frame with iBAQ intensities per protein group from peptides unique to this group
#' @examples
#' add
#' @export
ibaq_merge <- function(data, peptides) {
  # Filter for peptides not unique to a single protein group and sort their protein group IDs
  shared_pep <- peptides %>% filter(Unique..Groups. == "no")
  sorted_pep <- shared_pep %>% select(Protein.group.IDs) %>% mutate(Protein.group.IDs = lapply(Protein.group.IDs, function (x) strsplit(x, ";")[[1]] %>% as.numeric() %>% sort() %>% paste(., collapse = ";")))
  # Expand the protein groups from a single column to a matrix and filter for unique combinations
  max <- lapply(sorted_pep$Protein.group.IDs, function (x) strsplit(x, ";")[[1]] %>% length()) %>% unlist() %>% max()
  shared <- sorted_pep %>% separate(., Protein.group.IDs, paste0("X",1:max), sep = ";",fill = "right")
  shared_filt <- shared %>% mutate(paste = apply(shared, 1, function(x) paste(x[!is.na(x)], collapse = ":"))) %>% filter(!duplicated(paste)) %>% select(-paste)

  # Combine all protein group IDs that have overlapping peptides
  x <- list(shared_filt[1,!is.na(shared_filt[1,])]) # set first IDs group
  for(i in 2:nrow(shared_filt)) {
    ids <- shared_filt[i,!is.na(shared_filt[i,])] # get IDs of new row and check whether they match with any of the previous IDs
    if(any(ids %in% unlist(x))) {
      match <- ids[ids %in% unlist(x)] # Get the IDs that match
      if(length(match) == 1) { rows <- grep(paste("\\b", match, "\\b", sep = ""), x) } # Grep the rows of the single match
      if(length(match) > 1) { rows <- apply(match, 2, function(y) grep(paste("\\b", y, "\\b", sep = ""), x)) %>% unlist() %>% unique() } # Grep the rows of all matches
      if(length(rows) == 1) { x[[rows]] <- unique(unlist(c(unlist(x[[rows]]),ids))) } # Combine the single matched ID group with the current IDs
      if(length(rows) > 1) {
        x[[rows[1]]] <- unique(unlist(c(unlist(lapply(rows, function(y) x[[y]])),ids))) # Combine all matched ID groups and the current IDs in the first matched ID group and remove the others
        for(j in 2:length(rows)) {
          x[[rows[j]-j+2]] <- NULL
        }
      }
    }
    if (!any(ids %in% unlist(x))) {
      x[[(length(x) + 1)]] <- ids # In case there is no match with previous IDs groups, make a new IDs group
    }
  }

  # Function to convert the heterogenous list to a list of data.frames
  list2mat <- function(list) {
    if(is.character(list)) {
      dat <- t(as.data.frame(as.numeric(list)))
    } else {
      dat <- t(as.data.frame(as.numeric(list)))
    }
    colnames(dat) <- paste("X", 1:ncol(dat), sep = "")
    return(dat)
  }

  # Get all shared IDs
  shared_ids <- lapply(x, list2mat) %>% unlist(.)
  # Generate a single data.frame from the list of IDs groups
  rows2merge <- lapply(x, list2mat) %>% lapply(as.data.frame) %>% bind_rows()

  columns <- grep("iBAQ.", colnames(data))
  # Function to merge protein groups with shared peptides
  merge_sum <- function(rows) {
    sub <- data %>% filter(grepl(paste("^", rows, "$", collapse = "|", sep = ""), id))
    sub[1,columns] <- colSums(sub[,columns])
    sub$name[1] <- paste(unique(sub$name), collapse = ";")
    return(sub[1,] %>% select(name, columns))
  }
  merged <- apply(rows2merge, 1, merge_sum) %>% bind_rows()

  # Select all protein groups that only have peptides unique to this group
  data_unique <- data %>% filter(!id %in% shared_ids)

  # Generate the final list of all protein groups
  final <- rbind(data_unique %>% select(name, columns),merged)

  raw <- final[,2:ncol(final)]
  max <- lapply(final$name, function (x) strsplit(x, ";")[[1]] %>% length()) %>% unlist() %>% max()
  names <- final %>% separate(., name, paste0("name_",1:max), sep = ";",fill = "right", remove = FALSE)
  return(names)
}

#' Relative stoichiometry
#'
#' \code{stoichiometry} calculates relative stoichiometry of protein.
#'
#' @param data SummerizedExperiment, Data object generated by \code{\link{linear_model}} and \code{\link{cutoffs}}.
#' @param ibaq Data.frame, iBAQ object generated by \code{\link{ibaq_merge}}.
#' @param control Character, The condition to which the contrasts are generated (the control would be most appropriate).
#' @param bait Character, The name of the protein to which all other proteins will be scaled for the relative stoichiometry
#' @param level Numerical, The level to which the bait will be scaled
#' @return A data.frame with relative stoichiometry values per protein
#' @examples
#' add
#' @export
stoichiometry <- function(data, ibaq, control, bait, level = 1) {
  data <- data[rowData(data)$sign == "+", ]
  names <- rowData(data)$name
  rows <- ibaq %>% select(starts_with("name_")) %>% apply(., 2, function(x) grep(paste("^", names, "$", sep = "", collapse = "|"), x)) %>% unlist() %>% unique()
  sub <- ibaq[rows,] %>% select(name, starts_with("iBAQ."))

  ibaq_anno <- colData(data) %>% data.frame() %>% mutate(sample = paste("iBAQ.", ID, sep = ""))
  long <- sub %>% gather(sample, iBAQ, 2:ncol(.)) %>% left_join(., ibaq_anno, by = "sample")

  ctrl <- long %>% group_by(name, condition) %>% summarise(mean_ctrl = mean(iBAQ)) %>% filter(condition == control) %>% select(name, mean_ctrl)
  stoi <- long %>% left_join(., ctrl, by = "name") %>% filter(condition != control) %>% mutate(iBAQ = iBAQ - mean_ctrl)
  wide <- stoi %>% select(name, iBAQ, ID) %>% spread(ID, iBAQ)

  # Show error if an unvalid contrast is given
  if(length(grep(paste("^", bait, "$", sep = ""), wide$name)) == 0) {
    valid_baits_msg <- paste0("Valid baits are: '", paste0(wide$name, collapse = "', '"), "'")
    stop(
      "Not a valid bait, please run `stoichiometry()` with a valid bait as argument\n",
      valid_baits_msg,
      call. = FALSE)
  }

  num <- wide %>% filter(name == bait) %>%  .[,2:ncol(.)]
  num <- num / level
  final <- wide %>% mutate_each(funs(. / num$.), 2:ncol(.)) %>% gather(ID, iBAQ, 2:ncol(.)) %>% left_join(., ibaq_anno, by = "ID")
  return(final)
}

#' Plot the relative stoichiometry
#'
#' \code{plot_ibaq} plots a barplot of the relative stoichiometries of all proteins.
#'
#' @param data Data.frame, Stoichiometry object generated by \code{\link{stoichiometry}}.
#' @param thr Numerical, The stoichiometry threshold above which proteins will be plotted.
#' @param facet_condition Boolean, Whether or not to facet_wrap on the different conditions
#' @param max_y Numerical, The maximum scale of the y-axis.
#' @return A barplot
#' @examples
#' add
#' @export
plot_ibaq <- function(data, thr = 0.01, facet_condition = FALSE, max_y = NULL) {
  if(is.null(max_y)) {max <- max(df$ymax)} else { max <- max_y}
  df <- data %>% group_by(name, condition) %>% summarize(mean = mean(iBAQ), sd = sd(iBAQ)) %>% arrange(desc(mean)) %>% filter(mean >= thr) %>% ungroup(name)
  df %<>% mutate(name = ifelse(nchar(name) > 20, paste(substr(name, 1, 20), "~", sep = ""), name), ymin = mean - sd, ymax = mean + sd)
  df$name <- parse_factor(df$name, levels = unique(df$name))
  bait <- df %>% filter(mean == 1) %>% .$name %>% unique()
  if(facet_condition) {
    p1 <- ggplot(df, aes(x = name, y = mean)) + geom_bar(stat = "identity") + geom_errorbar(aes(ymax = ymax, ymin = ymin)) + facet_wrap(~condition) + theme_bw() + labs(x = "", y = paste("Stoichiometry (vs ", bait, ")", sep ="")) + ylim(0,max) +
      theme(axis.text=element_text(size=12), axis.text.x = element_text(angle = 90, hjust = 1, size = 8), axis.title=element_text(size=14,face="bold"), legend.text=element_text(size=12), legend.title = element_text(size=14,face="bold"), legend.position="right")
  } else {
    p1 <- ggplot(df, aes(x = name, y = mean, fill = condition)) + geom_bar(stat = "identity", position = "dodge") + geom_errorbar(aes(ymax = ymax, ymin = ymin)) + theme_bw() + labs(x = "", y = paste("Stoichiometry (vs ", bait, ")", sep ="")) +ylim(0,max) +
      theme(axis.text=element_text(size=12), axis.text.x = element_text(angle = 90, hjust = 1, size = 8), axis.title=element_text(size=14,face="bold"), legend.text=element_text(size=12), legend.title = element_text(size=14,face="bold"), legend.position="right")
  }
  p1
}
