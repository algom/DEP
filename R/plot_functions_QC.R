#' Plot row standard deviations versus row means
#'
#' \code{meanSdPlot} generates a hexagonal heatmap
#' of the row standard deviations versus row means
#' from SummarizedExperiment objects.
#' See \code{\link[vsn]{meanSdPlot}}.
#'
#' @param x SummarizedExperiment,
#' Data object.
#' @param ranks Logical,
#' Whether or not to plot the row means on the rank scale.
#' @param xlab Character,
#' x-axis label.
#' @param ylab Character,
#' y-axis label.
#' @param pch Ignored -
#' exists for backward compatibility.
#' @param plot Logical,
#' Whether or not to produce the plot.
#' @param bins Numeric vector,
#' Data object before normalization.
#' @param ... Other arguments,
#' Passed to \code{\link[ggplot2]{stat_binhex}}.
#' @return A scatter plot of row standard deviations
#' versus row means(generated by \code{\link[ggplot2]{stat_binhex}})
#' @examples
#' data <- UbiLength
#' data <- data[data$Reverse != '+' & data$Potential.contaminant != '+',]
#' data_unique <- make_unique(data, 'Gene.names', 'Protein.IDs', delim = ';')
#'
#' columns <- grep('LFQ.', colnames(data_unique))
#' exp_design <- UbiLength_ExpDesign
#' se <- make_se(data_unique, columns, exp_design)
#'
#' filt <- filter_missval(se, thr = 0)
#' norm <- normalize_vsn(filt)
#'
#' meanSdPlot(norm)
#' @export
meanSdPlot <- function(x,
                   ranks = TRUE,
                   xlab = ifelse(ranks, "rank(mean)", "mean"),
                   ylab = "sd",
                   pch,
                   plot = TRUE,
                   bins = 50,
                   ...) {
  vsn::meanSdPlot(assay(x),
                  ranks = ranks,
                  xlab = xlab,
                  ylab = ylab,
                  pch = pch,
                  plot = plot,
                  ...)
}

#' Visualize normalization
#'
#' \code{plot_normalization} generates boxplots
#' for all conditions before and after normalization.
#'
#' @param raw SummarizedExperiment,
#' Data object before normalization.
#' @param norm SummarizedExperiment,
#' Data object after normalization by \code{\link{normalize_vsn}}.
#' @return Boxplots for all conditions
#' before and after normalization (generated by \code{\link[ggplot2]{ggplot}}).
#' @examples
#' data <- UbiLength
#' data <- data[data$Reverse != '+' & data$Potential.contaminant != '+',]
#' data_unique <- make_unique(data, 'Gene.names', 'Protein.IDs', delim = ';')
#'
#' columns <- grep('LFQ.', colnames(data_unique))
#' exp_design <- UbiLength_ExpDesign
#' se <- make_se(data_unique, columns, exp_design)
#'
#' filt <- filter_missval(se, thr = 0)
#' norm <- normalize_vsn(filt)
#'
#' plot_normalization(filt, norm)
#' @export
plot_normalization <- function(raw, norm) {
    # Show error if inputs are not the required classes
    assertthat::assert_that(inherits(raw, "SummarizedExperiment"),
                            inherits(norm, "SummarizedExperiment"))

    # Show error if inputs do not contain required columns
    if (any(!c("label", "ID", "condition", "replicate") %in% colnames(colData(raw)))) {
        stop(paste0("'label', 'ID', 'condition' and/or 'replicate' columns are not present in '",
                    deparse(substitute(raw)),
                    "'.\nRun make_se() or make_se_parse() to obtain the required columns."),
            call. = FALSE)
    }
    if (any(!c("label", "ID", "condition", "replicate") %in% colnames(colData(norm)))) {
        stop(paste0("'label', 'ID', 'condition' and/or 'replicate' columns are not present in '",
                    deparse(substitute(norm)),
                    "'.\nRun make_se() or make_se_parse() to obtain the required columns."),
            call. = FALSE)
    }

    # Get a long data.frame of the assay data (original and normalized)
    # annotated with sample info
    df1 <- assay(raw) %>%
      data.frame() %>%
      rownames_to_column() %>%
      gather(ID, val, 2:ncol(.)) %>%
      left_join(., data.frame(colData(raw)), by = "ID") %>%
      mutate(var = "original")
    df2 <- assay(norm) %>%
      data.frame() %>%
      rownames_to_column() %>%
      gather(ID, val, 2:ncol(.)) %>%
      left_join(., data.frame(colData(norm)), by = "ID") %>%
      mutate(var = "normalized")
    df <- rbind(df1, df2)
    # Boxplots for conditions with facet_wrap
    # for the original and normalized values
    ggplot(df, aes(x = ID, y = val, fill = condition)) +
      geom_boxplot(notch = TRUE, na.rm = TRUE) +
      coord_flip() +
      facet_wrap(~var, ncol = 1) +
      labs(x = "", y = "Intensity (log2)") +
      theme_DEP1()
}

#' Visualize imputation
#'
#' \code{plot_imputation} generates density plots
#' for all conditions before and after imputation
#'
#' @param raw SummarizedExperiment,
#' Data object before imputation.
#' @param imp SummarizedExperiment,
#' Data object after imputation by \code{\link{impute}}.
#' @return Density plots for all conditions
#' before and after imputation (generated by \code{\link[ggplot2]{ggplot}}).
#' @examples
#' data <- UbiLength
#' data <- data[data$Reverse != '+' & data$Potential.contaminant != '+',]
#' data_unique <- make_unique(data, 'Gene.names', 'Protein.IDs', delim = ';')
#'
#' columns <- grep('LFQ.', colnames(data_unique))
#' exp_design <- UbiLength_ExpDesign
#' se <- make_se(data_unique, columns, exp_design)
#'
#' filt <- filter_missval(se, thr = 0)
#' norm <- normalize_vsn(filt)
#' imputed <- impute(norm, fun = 'MinProb', q = 0.01)
#'
#' plot_imputation(norm, imputed)
#' @export
plot_imputation <- function(raw, imp) {
    # Show error if inputs are not the required classes
    assertthat::assert_that(inherits(raw, "SummarizedExperiment"),
                            inherits(imp, "SummarizedExperiment"))

    # Show error if inputs do not contain required columns
    if (any(!c("label", "ID", "condition", "replicate") %in% colnames(colData(raw)))) {
        stop(paste0("'label', 'ID', 'condition' and/or 'replicate' columns are not present in '",
                    deparse(substitute(raw)),
                    "'.\nRun make_se() or make_se_parse() to obtain the required columns."),
            call. = FALSE)
    }
    if (any(!c("label", "ID", "condition", "replicate") %in% colnames(colData(imp)))) {
        stop(paste0("'label', 'ID', 'condition' and/or 'replicate' columns are not present in '",
                    deparse(substitute(imp)),
                    "'.\nRun make_se() or make_se_parse() to obtain the required columns."),
            call. = FALSE)
    }

    # Get a long data.frame of the assay data (original and imputed)
    # annotated with sample info
    df1 <- assay(raw) %>%
      data.frame() %>%
      rownames_to_column() %>%
      gather(ID, val, 2:ncol(.)) %>%
      left_join(., data.frame(colData(raw)), by = "ID") %>%
      mutate(var = "original")
    df2 <- assay(imp) %>%
      data.frame() %>%
      rownames_to_column() %>%
      gather(ID, val, 2:ncol(.)) %>%
      left_join(., data.frame(colData(imp)), by = "ID") %>%
      mutate(var = "imputed")
    df <- rbind(df1, df2)

    # Density plots for different conditions with facet_wrap
    # for original and imputed samles
    ggplot(df, aes(val, col = condition)) +
      geom_density(na.rm = TRUE) +
      facet_wrap(~var, ncol = 1) +
      labs(x = "Intensity (log2)", y = "Density") +
      theme_DEP1()
}

#' Visualize intensities of proteins with missing values
#'
#' \code{plot_detect} generates density and CumSum plots
#' of protein intensities with and without missing values
#'
#' @param se SummarizedExperiment,
#' Data object with missing values.
#' @return Density and CumSum plots of intensities of
#' proteins with and without missing values
#' (generated by \code{\link[ggplot2]{ggplot}}).
#' @examples
#' data <- UbiLength
#' data <- data[data$Reverse != '+' & data$Potential.contaminant != '+',]
#' data_unique <- make_unique(data, 'Gene.names', 'Protein.IDs', delim = ';')
#'
#' columns <- grep('LFQ.', colnames(data_unique))
#' exp_design <- UbiLength_ExpDesign
#' se <- make_se(data_unique, columns, exp_design)
#'
#' filt <- filter_missval(se, thr = 0)
#'
#' plot_detect(filt)
#' @export
plot_detect <- function(se) {
    # Show error if inputs are not the required classes
    assertthat::assert_that(inherits(se, "SummarizedExperiment"))

    # Show error if inputs do not contain required columns
    if (any(!c("label", "ID", "condition", "replicate") %in% colnames(colData(se)))) {
        stop(paste0("'label', 'ID', 'condition' and/or 'replicate' columns are not present in '",
                    deparse(substitute(se)),
                    "'.\nRun make_se() or make_se_parse() to obtain the required columns."),
            call. = FALSE)
    }

    # Get a long data.frame of the assay data annotated with sample info
    df <- assay(se) %>%
      data.frame() %>%
      rownames_to_column() %>%
      gather(ID, val, 2:ncol(.)) %>%
      left_join(., data.frame(colData(se)), by = "ID")

    # Get a summarized table with mean protein intensities and
    # indication whether the protein has missing values
    stat <- df %>%
      group_by(rowname) %>%
      summarize(mean = mean(val, na.rm = TRUE), missval = any(is.na(val)))

    # Calculate cumulative fraction
    cumsum <- stat %>%
      group_by(missval) %>%
      arrange(mean) %>%
      mutate(num = 1, cs = cumsum(num), cs_frac = cs/n())

    # Plot the densities and cumalitive fractions for
    # proteins with and without missing values
    p1 <- ggplot(stat, aes(mean, col = missval)) +
      geom_density(na.rm = TRUE) +
      labs(x = "Intensity (log2)", y = "Density") +
      guides(col = guide_legend(title = "Missing values")) +
      theme_DEP1()
    p2 <- ggplot(cumsum, aes(mean, cs_frac, col = missval)) +
      geom_line() +
      labs(x = "Intensity (log2)", y = "Cumulative fraction") +
      guides(col = guide_legend(title = "Missing values")) +
      theme_DEP1()
    gridExtra::grid.arrange(p1, p2, ncol = 1)
}

#' Plot a heatmap of proteins with missing values
#'
#' \code{plot_missval} generates a heatmap of proteins
#' with missing values to discover whether values are missing by random or not.
#'
#' @param se SummarizedExperiment,
#' Data object that contains missing values.
#' @return A heatmap indicating whether values are missing (0) or not (1)
#' (generated by \code{\link[ComplexHeatmap]{Heatmap}}).
#' @examples
#' data <- UbiLength
#' data <- data[data$Reverse != '+' & data$Potential.contaminant != '+',]
#' data_unique <- make_unique(data, 'Gene.names', 'Protein.IDs', delim = ';')
#'
#' columns <- grep('LFQ.', colnames(data_unique))
#' exp_design <- UbiLength_ExpDesign
#' se <- make_se(data_unique, columns, exp_design)
#'
#' filt <- filter_missval(se, thr = 0)
#' plot_missval(filt)
#' @export
plot_missval <- function(se) {
    # Show error if input is not the required classes
    assertthat::assert_that(inherits(se, "SummarizedExperiment"))

    # Show error if there are no missing values
    if(!any(is.na(assay(se)))) {
      stop(paste0("No missing values in '",
                  deparse(substitute(se)),
                  "'"),
           call. = FALSE)
    }

    # Make assay data binary (1 = valid value, 0 = missing value)
    df <- assay(se) %>% data.frame(.)
    missval <- df[apply(df, 1, function(x) any(is.na(x))), ]
    missval <- ifelse(is.na(missval), 0, 1)
    # Plot binary heatmap
    ht2 = Heatmap(missval,
                  col = c("white", "black"),
                  column_names_side = "top",
                  show_row_names = FALSE,
                  show_column_names = TRUE,
                  name = "Missing values pattern",
                  column_names_gp = gpar(fontsize = 16),
                  heatmap_legend_param = list(at = c(0, 1),
                                              labels = c("Missing value",
                                                         "Valid value")))
    draw(ht2, heatmap_legend_side = "top")
}
