#' Plot PCA
#'
#' \code{plot_pca} generates a PCA plot using the top variable proteins.
#'
#' @param data SummarizedExperiment,
#' Data object for which differentially enriched proteins are annotated
#' by \code{\link{test_diff}} and \code{\link{add_rejections}}.
#' @param x Integer,
#' The principle component to plot on the x-axis.
#' @param y Integer,
#' The principle component to plot on the y-axis.
#' @param n Integer,
#' The number of top variable proteins to consider.
#' @return A scatter plot (generated by \code{\link[ggplot2]{ggplot}}).
#' @examples
#' # load data
#' data <- UbiLength
#' data <- data[data$Reverse != '+' & data$Potential.contaminant != '+',]
#' exp_design <- UbiLength_ExpDesign
#'
#' # perform the differential enrichment test
#' results <- LFQ(data, exp_design, "MinProb", "Ctrl", "control")
#' signif <- results$signif # get the significance object
#'
#' # plot pca
#' plot_pca(signif)
#'
#' # or perform the step-by-step analysis
#' data_unique <- make_unique(data, 'Gene.names', 'Protein.IDs', delim = ';')
#' columns <- grep('LFQ.', colnames(data_unique))
#' se <- make_se(data_unique, columns, exp_design)
#'
#' filt <- filter_missval(se, thr = 0)
#' norm <- normalize_vsn(filt)
#' imputed <- impute(norm, fun = 'MinProb', q = 0.01)
#'
#' diff <- test_diff(imputed, 'Ctrl', 'control')
#' signif <- add_rejections(diff, alpha = 0.05, lfc = 1)
#'
#' plot_pca(signif)
#' @export
plot_pca <- function(data, x = 1, y = 2, n = 500) {
  if(is.numeric(x)) x <- as.integer(x)
  if(is.numeric(y)) y <- as.integer(y)
  if(is.numeric(n)) n <- as.integer(n)
  # Show error if inputs are not the required classes
  assertthat::assert_that(inherits(data, "SummarizedExperiment"),
                          is.integer(x),
                          is.integer(y),
                          is.integer(n))

  # Check for valid x and y values
  if(x > ncol(data) & x > ncol(data)) {
    stop(paste0("'x' and/or 'y' arguments are not valid.\n",
                "Run plot_pca() with 'x' and 'y' <= ",
                ncol(data),
                "."),
         call. = FALSE)
  }

  # Check for valid n value
  if(n > nrow(data)) {
    stop(paste0("'n' argument is not valid.\n",
                "Run plot_pca() with 'n' <= ",
                nrow(data),
                "."),
         call. = FALSE)
  }

  # Get the variance per protein and take the top n variable proteins
  var <- apply(assay(data), 1, sd)
  df <- assay(data)[order(var, decreasing = TRUE)[1:n],]

  # Calculate PCA
  pca <- prcomp(t(df), scale = FALSE)
  pca_df <- pca$x %>%
    data.frame() %>%
    rownames_to_column() %>%
    left_join(., data.frame(colData(data)), by = c("rowname" = "ID"))

  # Calculate the percentage of variance explained
  percent <- round(100 * pca$sdev^2 / sum(pca$sdev^2), 1)
  PC_cols <- grep("^PC", colnames(pca_df))
  colnames(pca_df)[PC_cols] <- paste0(colnames(pca_df)[PC_cols], ": ", percent, "%")

  # Select the PC to plot
  pca_df$x <- pca_df[, PC_cols[x]]
  pca_df$y <- pca_df[, PC_cols[y]]

  # Plot the PCA
  pca_df$replicate <- as.factor(pca_df$replicate)
  ggplot(pca_df, aes(x = x, y = y, col = condition, shape = replicate)) +
    geom_point(size = 6) +
    labs(title = paste0("PCA plot - top ", n, " variable proteins"),
         x = colnames(pca_df)[PC_cols[x]],
         y = colnames(pca_df)[PC_cols[y]]) +
    theme_DEP1()
}

#' Plot correlation matrix
#'
#' \code{plot_corr} generates a Pearson correlation matrix.
#'
#' @param data SummarizedExperiment,
#' Data object for which differentially enriched proteins are annotated
#' by \code{\link{test_diff}} and \code{\link{add_rejections}}.
#' @param significant Boolean,
#' Whether or not to filter for significant proteins.
#' @param lower Integer,
#' The lower limit of the color scale.
#' @param upper Integer,
#' The upper limit of the color scale.
#' @param pal Character,
#' The name of the color panel from \code{\link[RColorBrewer]{brewer.pal}}.
#' @param pal_rev Boolean,
#' Whether or not to invert the color palette.
#' @return A heatmap plot (generated by \code{\link[ComplexHeatmap]{Heatmap}})
#' @examples
#' # load data
#' data <- UbiLength
#' data <- data[data$Reverse != '+' & data$Potential.contaminant != '+',]
#' exp_design <- UbiLength_ExpDesign
#'
#' # perform the differential enrichment test
#' results <- LFQ(data, exp_design, "MinProb", "Ctrl", "control")
#' signif <- results$signif # get the significance object
#'
#' # plot correlation matrix
#' plot_corr(signif)
#' plot_corr(signif, lower = 0, upper = 1, pal = "Reds")
#'
#' # or perform the step-by-step analysis
#' data_unique <- make_unique(data, 'Gene.names', 'Protein.IDs', delim = ';')
#' columns <- grep('LFQ.', colnames(data_unique))
#' se <- make_se(data_unique, columns, exp_design)
#'
#' filt <- filter_missval(se, thr = 0)
#' norm <- normalize_vsn(filt)
#' imputed <- impute(norm, fun = 'MinProb', q = 0.01)
#'
#' diff <- test_diff(imputed, 'Ctrl', 'control')
#' signif <- add_rejections(diff, alpha = 0.05, lfc = 1)
#'
#' plot_corr(signif)
#' @export
plot_corr <- function(data, significant = TRUE, lower = -1, upper = 1, pal = "PRGn", pal_rev = FALSE) {
  # Show error if inputs are not the required classes
  assertthat::assert_that(inherits(data, "SummarizedExperiment"),
                          is.logical(significant),
                          is.numeric(lower),
                          is.numeric(upper),
                          is.character(pal),
                          is.logical(pal_rev))

  # Check for valid lower and upper values
  if(!(lower >= -1  & upper >= -1 & lower <= 1 & upper <= 1)) {
    stop(paste0("'lower' and/or 'upper' arguments are not valid.\n",
                "Run plot_pca() with 'lower' and 'upper' between -1 and 1."),
         call. = FALSE)
  }

  # Check for valid pal
  pals <- RColorBrewer::brewer.pal.info %>%
    rownames_to_column() %>%
    filter(category != "qual")
  if(!pal %in% pals$rowname) {
    stop(paste0("'", pal,"' is not a valid color panel",
                " (qualitative panels also not allowed).\n",
                "Run plot_pca() with one of the following 'pal' options: ",
                paste(pals$rowname, collapse = "', '"),
                "'."),
         call. = FALSE)
  }

  # Check for significant column
  if(!"significant" %in% colnames(rowData(data))) {
    stop(paste0("'significant' column is not present in '",
                deparse(substitute(data)),
                "'.\nRun add_rejections() to obtain the required column."),
         call. = FALSE)
  }

  # Filter for significant proteins
  if(significant) {
    data <- data[rowData(data)$significant, ]
  }

  # Calculate correlation matrix
  corr_mat <- cor(assay(data))

  # Plot heatmap
  ht1 = Heatmap(corr_mat,
                col = circlize::colorRamp2(
                  seq(lower, upper, ((upper-lower)/7)),
                  if(pal_rev) {
                    rev(RColorBrewer::brewer.pal(8, pal))
                  } else {
                    RColorBrewer::brewer.pal(8, pal)
                  }),
                cluster_columns = TRUE,
                cluster_rows = TRUE,
                na_col = "grey",
                clustering_distance_rows = "euclidean",
                clustering_distance_columns = "euclidean",
                row_names_side = "left",
                column_names_side = "top",
                show_row_names = TRUE,
                show_column_names = TRUE,
                heatmap_legend_param = list(color_bar = "continuous",
                                            legend_direction = "vertical",
                                            legend_width = unit(5, "cm"),
                                            title_position = "topcenter"),
                name = "Pearson correlation",
                column_names_gp = gpar(fontsize = 15),
                row_names_gp = gpar(fontsize = 15))
  draw(ht1, heatmap_legend_side = "right")
}

#' Plot frequency of significant conditions per protein
#'
#' \code{plot_cond_freq} generates a histogram of the number of significant conditions per protein.
#'
#' @param data SummarizedExperiment,
#' Data object for which differentially enriched proteins are annotated
#' by \code{\link{test_diff}} and \code{\link{add_rejections}}.
#' @return A histogram (generated by \code{\link[ggplot2]{ggplot}})
#' @examples
#' # load data
#' data <- UbiLength
#' data <- data[data$Reverse != '+' & data$Potential.contaminant != '+',]
#' exp_design <- UbiLength_ExpDesign
#'
#' # perform the differential enrichment test
#' results <- LFQ(data, exp_design, "MinProb", "Ctrl", "control")
#' signif <- results$signif # get the significance object
#'
#' # plot frequencies
#' plot_cond_freq(signif)
#'
#' # or perform the step-by-step analysis
#' data_unique <- make_unique(data, 'Gene.names', 'Protein.IDs', delim = ';')
#' columns <- grep('LFQ.', colnames(data_unique))
#' se <- make_se(data_unique, columns, exp_design)
#'
#' filt <- filter_missval(se, thr = 0)
#' norm <- normalize_vsn(filt)
#' imputed <- impute(norm, fun = 'MinProb', q = 0.01)
#'
#' diff <- test_diff(imputed, 'Ctrl', 'control')
#' signif <- add_rejections(diff, alpha = 0.05, lfc = 1)
#'
#' plot_cond_freq(signif)
#' @export
plot_cond_freq <- function(data) {
  # Show error if inputs are not the required classes
  assertthat::assert_that(inherits(data, "SummarizedExperiment"))

  # Check for significance columns
  if(length(grep("_significant", colnames(rowData(data)))) < 1) {
    stop(paste0("'[contrast]_significant' columns are not present in '",
                deparse(substitute(data)),
                "'.\nRun add_rejections() to obtain the required columns."),
         call. = FALSE)
  }

  # Check for significant column
  if(!"significant" %in% colnames(rowData(data))) {
    stop(paste0("'significant' column is not present in '",
                deparse(substitute(data)),
                "'.\nRun add_rejections() to obtain the required column."),
         call. = FALSE)
  }

  # Filter for significant proteins
  data <- data[rowData(data)$significant, ]

  # Get significant columns and count significant conditions per protein
  row_data <- rowData(data) %>% data.frame()
  cols <- grep("_significant", colnames(row_data))
  df <- row_data %>%
    select(name, ID, cols) %>%
    gather(condition, significant, 3:ncol(.)) %>%
    mutate(val = ifelse(significant, 1, 0))
  stat <- df %>%
    group_by(name) %>%
    summarize(sum = sum(val), n = n())
  # Get a counts table
  table <- table(stat$sum) %>% data.frame()

  # Plot the count table as a bar graph
  ggplot(table, aes(x = Var1, y = Freq, fill = Var1)) +
    geom_bar(stat = "identity") +
    labs(x = "Number of significant conditions",
         y = "Number of proteins",
         title = "Frequency of significant conditions per protein") +
    DEP::theme_DEP1() +
    theme(legend.position = "none")
}

#' Plot conditions overlap
#'
#' \code{plot_cond_overlap} generates a histogram of
#' the number of proteins per condition or overlapping conditions.
#'
#' @param data SummarizedExperiment,
#' Data object for which differentially enriched proteins are annotated
#' by \code{\link{test_diff}} and \code{\link{add_rejections}}.
#' @return A histogram (generated by \code{\link[ggplot2]{ggplot}})
#' @examples
#' # load data
#' data <- UbiLength
#' data <- data[data$Reverse != '+' & data$Potential.contaminant != '+',]
#' exp_design <- UbiLength_ExpDesign
#'
#' # perform the differential enrichment test
#' results <- LFQ(data, exp_design, "MinProb", "Ctrl", "control")
#' signif <- results$signif # get the significance object
#'
#' # plot overlap
#' plot_cond_overlap(signif)
#'
#' # or perform the step-by-step analysis
#' data_unique <- make_unique(data, 'Gene.names', 'Protein.IDs', delim = ';')
#' columns <- grep('LFQ.', colnames(data_unique))
#' se <- make_se(data_unique, columns, exp_design)
#'
#' filt <- filter_missval(se, thr = 0)
#' norm <- normalize_vsn(filt)
#' imputed <- impute(norm, fun = 'MinProb', q = 0.01)
#'
#' diff <- test_diff(imputed, 'Ctrl', 'control')
#' signif <- add_rejections(diff, alpha = 0.05, lfc = 1)
#'
#' plot_cond_overlap(signif)
#' @export
plot_cond_overlap <- function(data) {
  # Show error if inputs are not the required classes
  assertthat::assert_that(inherits(data, "SummarizedExperiment"))

  # Check for significance columns
  if(length(grep("_significant", colnames(rowData(data)))) < 1) {
    stop(paste0("'[contrast]_significant' columns are not present in '",
                deparse(substitute(data)),
                "'.\nRun add_rejections() to obtain the required columns."),
         call. = FALSE)
  }

  # Check for significant column
  if(!"significant" %in% colnames(rowData(data))) {
    stop(paste0("'significant' column is not present in '",
                deparse(substitute(data)),
                "'.\nRun add_rejections() to obtain the required column."),
         call. = FALSE)
  }

  # Filter for significant proteins
  data <- data[rowData(data)$significant, ]

  # Get significant columns
  row_data <- rowData(data) %>% data.frame()
  cols <- grep("_significant", colnames(row_data))
  colnames(row_data)[cols] <- gsub("_significant", "", colnames(row_data)[cols])

  # Rename column names
  row_data_renamed <- row_data
  colnames(row_data_renamed)[cols] <- LETTERS[seq(to = length(cols))]
  legend <- data.frame(symbol = colnames(row_data_renamed)[cols], names = colnames(row_data)[cols])

  # Get co-occurence matrix
  df <- select(row_data_renamed, name, ID, cols)
  counts <- table(df[,3:(length(cols)+2)]) %>%
    tidy() %>%
    filter(Freq > 0)

  # Parse condition names
  mat <- counts[,1:(ncol(counts)-1)] == TRUE
  counts$conditions <-
    apply(mat, 1, function(x) {
      paste0(colnames(counts[,1:(ncol(counts)-1)])[x], collapse = " ")
    })

  # Sort on number of conditions
  counts$n_con <- apply(mat, 1, function(x) length(which(x)))
  counts <- counts %>%
    arrange(n_con, conditions)
  counts$conditions <- parse_factor(counts$conditions, levels = counts$conditions)

  if(nrow(counts) <= 40 ) {
    labelsize = 12
  } else {
    labelsize = 12 / (nrow(counts) / 40)
  }

  # Plot conditions overlap histogram
  p1 <- ggplot(counts, aes(x = conditions, y = Freq)) +
    geom_col(fill = "black") +
    labs(title = "Overlap between conditions",
         x = "Conditions",
         y = "Number of Proteins") +
    theme_DEP2() +
    theme(axis.text=element_text(size = labelsize))

  # Legend table
  ttheme <- gridExtra::ttheme_minimal(
    core=list(fg_params=list(hjust=0, x=0.1)))
  p2 <- gridExtra::tableGrob(legend, theme = ttheme, rows = NULL, cols = NULL)
  gridExtra::grid.arrange(p1, p2, ncol = 2, widths = c(0.8, 0.2))
}
