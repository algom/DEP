#' Plot values for a protein of interest
#'
#' \code{plot_single} generates a barplot of a protein of interest.
#'
#' @param data SummarizedExperiment, Data object which has been generated by \code{\link{test_diff}} and \code{\link{add_rejections}}.
#' @param protein Character, Protein name.
#' @param type "centered" or "contrast", The type of data scaling used for plotting.
#' @return A barplot (generated by \code{\link[ggplot2]{ggplot}})
#' @examples
#' data <- UbiLength
#' data <- filter(data, Reverse != "+", Potential.contaminant != "+")
#' data_unique <- make_unique(data, "Gene.names", "Protein.IDs", delim = ";")
#'
#' columns <- grep("LFQ.", colnames(data_unique))
#' exp_design <- UbiLength_ExpDesign
#' se <- make_se(data_unique, columns, exp_design)
#'
#' filt <- filter_missval(se, thr = 0)
#' norm <- normalize_vsn(filt)
#' imputed <- impute(norm, fun = "MinProb", q = 0.01)
#'
#' diff <- test_diff(imputed, "Ctrl", "control")
#' signif <- add_rejections(diff, alpha = 0.05, lfc = 1)
#'
#' plot_single(signif, "USP15", "centered")
#' plot_single(signif, "USP15", "contrast")
#' @export
plot_single <- function(data, protein, type) {
  # Show error if inputs are not the required classes
  assertthat::assert_that(inherits(data, "SummarizedExperiment"), is.character(protein), is.character(type))

  # Show error if inputs do not contain required columns
  if (any(!c("label", "condition", "replicate") %in% colnames(colData(data)))) {
    stop(paste0("'label', 'condition' and/or 'replicate' columns are not present in '", deparse(substitute(data)) ,"'.\nRun make_se() or make_se_parse() to obtain the required columns."), call. = FALSE)
  }
  if (length(grep("_p.adj|_diff", colnames(rowData(data)))) < 1) {
    stop(paste0("'[contrast]_diff' and '[contrast]_p.adj' columns are not present in '", deparse(substitute(data)), "'.;\nRun test_diff() to obtain the required columns."), call. = FALSE)
  }
  if (!"name" %in% colnames(rowData(data))) {
    stop(paste0("'name' column not present in '", deparse(substitute(data)), "'"), call. = FALSE)
  }
  # Show error if an unvalid type is given
  if (!type %in% c("centered", "contrast")) {
    stop("run plot_single() with a valid type;\nValid types are: 'centered', 'contrast'", call. = FALSE)
  }
  # Show error if an unvalid protein name is given
  if(length(which(rowData(data)$name == protein)) == 0) {
    possibilities <- rowData(data)$name[grep(substr(protein, 1, nchar(protein)-1), rowData(data)$name)]
    if (length(possibilities) > 0){
      possibilities_msg <- paste0("Do you mean: '", paste0(possibilities, collapse = "', '"), "'")
    } else { possibilities_msg <- NULL}
    stop(
      "please run `plot_single()` with a valid protein name as argument\n",
      possibilities_msg,
      call. = FALSE)
  }

  # Plot either the average protein-centered enrichment values per condition ("centered") or
  # the average enrichments of conditions versus the control condition ("contrast") for a single protein
  if(type == "centered") {
    # Obtain protein-centered enrichment values
    rowData(data)$mean <- rowMeans(assay(data))
    df <- assay(data) - rowData(data)$mean
    df %<>% data.frame(.) %>% rownames_to_column(.)
    # Select values for a single protein in long format and add sample annotation
    df %<>% filter(rowname == protein) %>% gather(ID, val, 2:ncol(.)) %>% left_join(., data.frame(colData(data)), by = "ID")
    df$replicate <- as.factor(df$replicate)
    # Plot the centered enrichment values for the replicates as well as the mean
    p1 <- ggplot(df, aes(condition, val, col = replicate)) + geom_hline(yintercept = 0) +
      stat_summary(fun.y = "mean", colour = "black", size = 0, geom = "bar", fill = "black") + geom_point(shape = 17, size = 4) +
      labs(title = unique(df$rowname), x = "Baits", y = "Enrichment (log2)") + theme_DEP2()
  }
  if(type == "contrast") {
    # Obtain average enrichments of conditions versus the control condition
    df <- rowData(data) %>% data.frame() %>% column_to_rownames(var = "name") %>% select(ends_with("_diff")) %>% rownames_to_column(.)
    colnames(df)[2:ncol(df)] %<>%  gsub("_diff", "", .) %>% gsub("_vs_", " - ", .)
    # Select values for a single protein in long format
    df %<>% filter(rowname == protein) %>% gather(condition, LFC, 2:ncol(.))
    # Plot the average enrichments of conditions versus the control condition
    p1 <- ggplot(df, aes(condition, LFC)) + geom_hline(yintercept = 0) + geom_bar(stat = "unique", size = 0, col = "black", fill = "black") +
      labs(title = unique(df$rowname), x = "", y = "Enrichment (log2)") + theme_DEP2()
  }
  p1
}

#' Plot a heatmap
#'
#' \code{plot_heatmap} generates a heatmap of all significant proteins.
#'
#' @param data SummarizedExperiment, Data object which has been generated by \code{\link{test_diff}} and \code{\link{add_rejections}}.
#' @param type "centered" or "contrast", The type of data scaling used for plotting.
#' @param k Integer, sets the number of k-means clusters.
#' @param col_limit Integer, sets the outer limits of the color scale.
#' @param labelsize Integer, sets the size of name labels.
#' @return A heatmap (generated by \code{\link[ComplexHeatmap]{Heatmap}})
#' @examples
#' data <- UbiLength
#' data <- filter(data, Reverse != "+", Potential.contaminant != "+")
#' data_unique <- make_unique(data, "Gene.names", "Protein.IDs", delim = ";")
#'
#' columns <- grep("LFQ.", colnames(data_unique))
#' exp_design <- UbiLength_ExpDesign
#' se <- make_se(data_unique, columns, exp_design)
#'
#' filt <- filter_missval(se, thr = 0)
#' norm <- normalize_vsn(filt)
#' imputed <- impute(norm, fun = "MinProb", q = 0.01)
#'
#' diff <- test_diff(imputed, "Ctrl", "control")
#' signif <- add_rejections(diff, alpha = 0.05, lfc = 1)
#'
#' plot_heatmap(signif, "centered", k = 6, col_limit = 4, labelsize = 3)
#' plot_heatmap(signif, "contrast", k = 6, col_limit = 10, labelsize = 3)
#' @export
plot_heatmap <- function(data, type, k = 6, col_limit = 6, labelsize = 10) {
  # Show error if inputs are not the required classes
  if(is.integer(k)) k <- as.numeric(k)
  if(is.integer(col_limit)) col_limit <- as.numeric(col_limit)
  if(is.integer(labelsize)) labelsize <- as.numeric(labelsize)
  assertthat::assert_that(inherits(data, "SummarizedExperiment"), is.character(type),
              is.numeric(k), is.numeric(col_limit), is.numeric(labelsize))

  # Show error if inputs do not contain required columns
  if (any(!c("label", "condition", "replicate") %in% colnames(colData(data)))) {
    stop(paste0("'label', 'condition' and/or 'replicate' columns are not present in '", deparse(substitute(data)), "'"), call. = FALSE)
  }
  if (length(grep("_diff", colnames(rowData(data)))) < 1) {
    stop(paste0("'[contrast]_diff' columns are not present in '", deparse(substitute(data)), "'.\nRun test_diff() to obtain the required columns."), call. = FALSE)
  }
  if (!"significant" %in% colnames(rowData(data))) {
    stop(paste0("'significant' column is not present in '", deparse(substitute(data)), "'.\nRun add_rejections() to obtain the required column."), call. = FALSE)
  }

  # Show error if an unvalid type is given
  if (!type %in% c("centered", "contrast")) {
    stop("run plot_heatmap() with a valid type;\nValid types are: 'centered', 'contrast'", call. = FALSE)
  }

  # Filter for significant proteins only
  data <- data[rowData(data)$significant, ]

  # Plot a heatmap of the average protein-centered enrichment values per condition ("centered") or
  # the average enrichments of conditions versus the control condition ("contrast")
  if(type == "centered") {
    # Obtain protein-centered enrichment values
    rowData(data)$mean <- rowMeans(assay(data))
    df <- assay(data) - rowData(data)$mean

    # Perform k-means clustering
    set.seed(1)
    kmeans <- kmeans(df,k)
    # Order the k-means clusters according to the maximum enrichment in all samples averaged over the proteins in the cluster
    order <- df %>% data.frame() %>% cbind(., cluster = kmeans$cluster) %>%
      mutate(row = apply(.[,1:(ncol(.)-1)], 1, function(x) max(x))) %>% group_by(cluster) %>%
      summarize(index=sum(row)/n()) %>% arrange(desc(index)) %>% collect %>% .[[1]] %>% match(seq(1:k),.)
    kmeans$cluster <- order[kmeans$cluster]
  }
  if(type == "contrast") {
    # Obtain average enrichments of conditions versus the control condition
    df <- rowData(data) %>% data.frame() %>% column_to_rownames(var = "name") %>% select(ends_with("_diff"))
    colnames(df) %<>% gsub("_diff","" , .) %>% gsub("_vs_", " - ", .)

    # Perform k-means clustering
    set.seed(1)
    kmeans <- kmeans(df,k)
    # Order the k-means clusters according to their average enrichment
    order <- cbind(df, cluster = kmeans$cluster) %>% gather(condition, diff, 1:(ncol(.)-1)) %>% group_by(cluster) %>%
      summarize(row = mean(diff)) %>% arrange(desc(row)) %>% collect %>% .[[1]] %>% match(seq(1:k),.)
    kmeans$cluster <- order[kmeans$cluster]
  }

  if(ncol(df) == 1) { clust = FALSE } else { clust = TRUE }

  # Plot the heatmap
  ht1 = Heatmap(df, col = circlize::colorRamp2(seq(-col_limit, col_limit, (col_limit/5)), rev(RColorBrewer::brewer.pal(11, "RdBu"))), split = kmeans$cluster,
                cluster_columns = T, cluster_rows = clust, na_col = "grey", clustering_distance_rows = "pearson",clustering_distance_columns = "pearson",
                row_names_side = "left", column_names_side = "top", show_row_names = T, show_column_names = T,
                heatmap_legend_param = list(color_bar = "continuous", legend_direction = "horizontal", legend_width = unit(5, "cm"), title_position = "lefttop"),
                name = "Enrichment (Log2)", row_names_gp = gpar(fontsize = labelsize), column_names_gp = gpar(fontsize = 16))
  draw(ht1, heatmap_legend_side = "top")
}

#' Volcano plot
#'
#' \code{plot_volcano} generates a volcano plot for a specified contrast.
#'
#' @param data SummarizedExperiment, Data object which has been generated by \code{\link{test_diff}} and \code{\link{add_rejections}}.
#' @param contrast Character, The specific contrast to plot.
#' @param labelsize Integer, sets the size of name labels.
#' @param add_names Boolean, whether or not to plot names.
#' @return A volcano plot (generated by \code{\link[ggplot2]{ggplot}})
#' @examples
#' data <- UbiLength
#' data <- filter(data, Reverse != "+", Potential.contaminant != "+")
#' data_unique <- make_unique(data, "Gene.names", "Protein.IDs", delim = ";")
#'
#' columns <- grep("LFQ.", colnames(data_unique))
#' exp_design <- UbiLength_ExpDesign
#' se <- make_se(data_unique, columns, exp_design)
#'
#' filt <- filter_missval(se, thr = 0)
#' norm <- normalize_vsn(filt)
#' imputed <- impute(norm, fun = "MinProb", q = 0.01)
#'
#' diff <- test_diff(imputed, "Ctrl", "control")
#' signif <- add_rejections(diff, alpha = 0.05, lfc = 1)
#'
#' plot_volcano(signif, "Ubi6_vs_Ctrl", labelsize = 5, add_names = TRUE)
#' plot_volcano(signif, "Ubi6_vs_Ctrl", add_names = FALSE)
#' plot_volcano(signif, "Ubi4_vs_Ctrl", labelsize = 5, add_names = TRUE)
#' plot_volcano(signif, "Ubi4_vs_Ctrl", add_names = FALSE)
#' @export
plot_volcano <- function(data, contrast, labelsize = 3, add_names = TRUE) {
  # Show error if inputs are not the required classes
  if(is.integer(labelsize)) labelsize <- as.numeric(labelsize)
  assertthat::assert_that(inherits(data, "SummarizedExperiment"), is.character(contrast),
              is.numeric(labelsize), is.logical(add_names))

  # Show error if inputs do not contain required columns
  if (any(!c("name", "ID") %in% colnames(rowData(data)))) {
    stop(paste0("'name' and/or 'ID' columns are not present in '", deparse(substitute(data)), "'.\nRun make_unique() to obtain required columns."), call. = FALSE)
  }
  if (length(grep("_p.adj|_diff", colnames(rowData(data)))) < 1) {
    stop(paste0("'[contrast]_diff' and '[contrast]_p.adj' columns are not present in '", deparse(substitute(data)), "'.\nRun test_diff() to obtain the required columns."), call. = FALSE)
  }
  if (length(grep("_significant", colnames(rowData(data)))) < 1) {
    stop(paste0("'[contrast]_significant' columns are not present in '", deparse(substitute(data)), "'.\nRun add_rejections() to obtain the required columns."), call. = FALSE)
  }

  row_data <- rowData(data)

  # Show error if an unvalid contrast is given
  if(length(grep(paste(contrast, "_diff", sep = ""), colnames(row_data))) == 0) {
    valid_cntrsts <- row_data %>% data.frame() %>% select(ends_with("_diff")) %>% colnames(.) %>% gsub("_diff", "", .)
    valid_cntrsts_msg <- paste0("Valid contrasts are: '", paste0(valid_cntrsts, collapse = "', '"), "'")
    stop(
      "Not a valid contrast, please run `plot_volcano()` with a valid contrast as argument\n",
      valid_cntrsts_msg,
      call. = FALSE)
    }

  # Generate a data.frame containing all info for the volcano plot
  diff <- grep(paste(contrast, "_diff", sep = ""), colnames(row_data)) # All log2 fold change columns
  padj <- grep(paste(contrast, "_p.adj", sep = ""), colnames(row_data)) # All adjusted p-value columns
  signif <- grep(paste(contrast, "_significant", sep = ""), colnames(row_data)) # All significance columns
  df <- data.frame(x = row_data[,diff], y = -log10(row_data[,padj]) , z = row_data[,signif], name = row_data$name)
  signif_prots <- df %>% filter(z)
  name1 <- gsub("_vs_.*", "", contrast)
  name2 <- gsub(".*_vs_", "", contrast)

  # Plot volcano with or without labels
  if(add_names) {
    p1 <- ggplot(df, aes(x, y)) + geom_vline(xintercept = 0) + geom_point(col = "grey") + geom_point(data = signif_prots, col = "black") +
      ggrepel::geom_text_repel(data = signif_prots, aes(label = name), size = labelsize, point.padding = unit(0.3, "lines")) +
      geom_text(data = data.frame(), aes(x = c(Inf, -Inf), y = c(-Inf, -Inf), hjust = c(1, 0), vjust = c(-1, -1), label = c(name1, name2), size = 5, fontface = "bold")) +
      labs(x = "Log2 Fold Change", y = "-log10 adjusted P value") + theme_DEP1()
  } else {
    p1 <- ggplot(df, aes(x, y)) + geom_vline(xintercept = 0) + geom_point(col = "grey") + geom_point(data = signif_prots, col = "black") +
      geom_text(data = data.frame(), aes(x = c(Inf, -Inf), y = c(-Inf, -Inf), hjust = c(1, 0), vjust = c(-1, -1), label = c(name1, name2), size = 5, fontface = "bold")) +
      labs(x = "Log2 Fold Change", y = "-log10 adjusted P value") + theme_DEP1()
  }
  p1
}

#' Visualize normalization
#'
#' \code{plot_normalization} generates boxplots for all conditions before and after normalization.
#'
#' @param raw SummarizedExperiment, Data object before normalization.
#' @param norm SummarizedExperiment, Data object after normalization by \code{\link{normalize_vsn}}.
#' @return Boxplots for all conditions before and after normalization (generated by \code{\link[ggplot2]{ggplot}})
#' @examples
#' data <- UbiLength
#' data <- filter(data, Reverse != "+", Potential.contaminant != "+")
#' data_unique <- make_unique(data, "Gene.names", "Protein.IDs", delim = ";")
#'
#' columns <- grep("LFQ.", colnames(data_unique))
#' exp_design <- UbiLength_ExpDesign
#' se <- make_se(data_unique, columns, exp_design)
#'
#' filt <- filter_missval(se, thr = 0)
#' norm <- normalize_vsn(filt)
#'
#' plot_normalization(filt, norm)
#' @export
plot_normalization <- function(raw, norm) {
  # Show error if inputs are not the required classes
  assertthat::assert_that(inherits(raw, "SummarizedExperiment"), inherits(norm, "SummarizedExperiment"))

  # Show error if inputs do not contain required columns
  if (any(!c("label", "ID", "condition", "replicate") %in% colnames(colData(raw)))) {
    stop(paste0("'label', 'ID', 'condition' and/or 'replicate' columns are not present in '", deparse(substitute(raw)), "'.\nRun make_se() or make_se_parse() to obtain the required columns."), call. = FALSE)
  }
  if (any(!c("label", "ID", "condition", "replicate") %in% colnames(colData(norm)))) {
    stop(paste0("'label', 'ID', 'condition' and/or 'replicate' columns are not present in '", deparse(substitute(norm)), "'.\nRun make_se() or make_se_parse() to obtain the required columns."), call. = FALSE)
  }

  # Get a long data.frame of the assay data (original and normalized) annotated with sample info
  df1 <- assay(raw) %>% data.frame() %>% rownames_to_column(.) %>% gather(ID, val, 2:ncol(.)) %>% left_join(., data.frame(colData(raw)), by = "ID") %>% mutate(var = "original")
  df2 <- assay(norm) %>% data.frame() %>% rownames_to_column(.) %>% gather(ID, val, 2:ncol(.)) %>% left_join(., data.frame(colData(norm)), by = "ID") %>% mutate(var = "normalized")
  df <- rbind(df1, df2)
  # Boxplots for conditions with facet_wrap for the original and normalized values
  ggplot(df, aes(x = ID, y = val, fill = condition)) + geom_boxplot(notch = T, na.rm=TRUE) + coord_flip() + facet_wrap(~var, ncol = 1) +
    labs(x = "", y = "Log2 Intensity") + theme_DEP1()
}

#' Visualize imputation
#'
#' \code{plot_imputation} generates density plots for all conditions before and after imputation
#'
#' @param raw SummarizedExperiment, Data object before imputation
#' @param imp SummarizedExperiment, Data object after imputation by \code{\link{impute}}.
#' @return Density plots for all conditions before and after imputated (generated by \code{\link[ggplot2]{ggplot}})
#' @examples
#' data <- UbiLength
#' data <- filter(data, Reverse != "+", Potential.contaminant != "+")
#' data_unique <- make_unique(data, "Gene.names", "Protein.IDs", delim = ";")
#'
#' columns <- grep("LFQ.", colnames(data_unique))
#' exp_design <- UbiLength_ExpDesign
#' se <- make_se(data_unique, columns, exp_design)
#'
#' filt <- filter_missval(se, thr = 0)
#' norm <- normalize_vsn(filt)
#' imputed <- impute(norm, fun = "MinProb", q = 0.01)
#'
#' plot_imputation(norm, imputed)
#' @export
plot_imputation <- function (raw, imp)
{
  # Show error if inputs are not the required classes
  assertthat::assert_that(inherits(raw, "SummarizedExperiment"),
                          inherits(imp, "SummarizedExperiment"))

  # Show error if inputs do not contain required columns
  if (any(!c("label", "ID", "condition", "replicate") %in% colnames(colData(raw)))) {
    stop(paste0("'label', 'ID', 'condition' and/or 'replicate' columns are not present in '", deparse(substitute(raw)), "'.\nRun make_se() or make_se_parse() to obtain the required columns."), call. = FALSE)
  }
  if (any(!c("label", "ID", "condition", "replicate") %in% colnames(colData(imp)))) {
    stop(paste0("'label', 'ID', 'condition' and/or 'replicate' columns are not present in '", deparse(substitute(imp)), "'.\nRun make_se() or make_se_parse() to obtain the required columns."), call. = FALSE)
  }

  # Get a long data.frame of the assay data (original and imputed) annotated with sample info
  df1 <- assay(raw) %>% data.frame() %>% rownames_to_column(.) %>%
    gather(ID, val, 2:ncol(.)) %>% left_join(., data.frame(colData(raw)), by = "ID") %>% mutate(var = "original")
  df2 <- assay(imp) %>% data.frame() %>% rownames_to_column(.) %>%
    gather(ID, val, 2:ncol(.)) %>% left_join(., data.frame(colData(imp)), by = "ID") %>% mutate(var = "imputed")
  df <- rbind(df1, df2)

  # Density plots for different conditions with facet_wrap for original and imputed samles
  ggplot(df, aes(val, col = condition)) + geom_density(na.rm = TRUE) + facet_wrap(~var, ncol = 1) +
    labs(x = "Log2 Intensity", y = "Density") + theme_DEP1()
}

#' Visualize intensities of proteins with missing values
#'
#' \code{plot_detect} generates density and CumSum plots of protein intensities with and without missing values
#'
#' @param data SummarizedExperiment, Data object with missing values
#' @return Density and CumSum plots of intensities of protein with missing values (generated by \code{\link[ggplot2]{ggplot}})
#' @examples
#' data <- UbiLength
#' data <- filter(data, Reverse != "+", Potential.contaminant != "+")
#' data_unique <- make_unique(data, "Gene.names", "Protein.IDs", delim = ";")
#'
#' columns <- grep("LFQ.", colnames(data_unique))
#' exp_design <- UbiLength_ExpDesign
#' se <- make_se(data_unique, columns, exp_design)
#'
#' filt <- filter_missval(se, thr = 0)
#'
#' plot_detect(filt)
#' @export
plot_detect <- function(data) {
  # Show error if inputs are not the required classes
  assertthat::assert_that(inherits(data, "SummarizedExperiment"))

  # Show error if inputs do not contain required columns
  if (any(!c("label", "ID", "condition", "replicate") %in% colnames(colData(data)))) {
    stop(paste0("'label', 'ID', 'condition' and/or 'replicate' columns are not present in '", deparse(substitute(data)), "'.\nRun make_se() or make_se_parse() to obtain the required columns."), call. = FALSE)
  }

  # Get a long data.frame of the assay data annotated with sample info
  df <- assay(data) %>% data.frame() %>% rownames_to_column(.) %>%
    gather(ID, val, 2:ncol(.)) %>% left_join(., data.frame(colData(data)), by = "ID")

  # Get a summarized table with mean protein intensities and indication whether the protein has missing values
  stat <- df %>% group_by(rowname) %>% summarize(mean = mean(val, na.rm = TRUE), missval = any(is.na(val)))

  # Calculate cumulative fraction
  cumsum <- stat %>% group_by(missval) %>% arrange(mean) %>% mutate(num = 1, cs = cumsum(num), cs_frac = cs / n())

  # Plot the densities and cumalitive fractions for proteins with and without missing values
  p1 <- ggplot(stat, aes(mean, col = missval)) + geom_density(na.rm = TRUE) +
    labs(x = "Log2 Intensity", y = "Density") + guides(col=guide_legend(title="missing values")) + theme_DEP1()
  p2 <- ggplot(cumsum, aes(mean, cs_frac, col = missval)) + geom_line() +
    labs(x = "Log2 Intensity", y = "Cumulative fraction") + guides(col=guide_legend(title="missing values")) + theme_DEP1()
  gridExtra::grid.arrange(p1, p2, ncol = 1)
}

#' Plot a heatmap of proteins with missing values
#'
#' \code{plot_missval} generates a heatmap of proteins with missing values to discover whether values are missing by random or not.
#'
#' @param data SummarizedExperiment, Data object which has been generated by \code{\link{test_diff}} and \code{\link{add_rejections}}.
#' @return A heatmap indicating whether values are missing (0) or not (1) (generated by \code{\link[ComplexHeatmap]{Heatmap}})
#' @examples
#' data <- UbiLength
#' data <- filter(data, Reverse != "+", Potential.contaminant != "+")
#' data_unique <- make_unique(data, "Gene.names", "Protein.IDs", delim = ";")
#'
#' columns <- grep("LFQ.", colnames(data_unique))
#' exp_design <- UbiLength_ExpDesign
#' se <- make_se(data_unique, columns, exp_design)
#'
#' filt <- filter_missval(se, thr = 0)
#' plot_missval(filt)
#' @export
plot_missval <- function(data) {
  # Show error if input is not the required classes
  assertthat::assert_that(inherits(data, "SummarizedExperiment"))

  # Make assay data binary (1 = valid value, 0 = missing value)
  df <- assay(data) %>% data.frame(.)
  missval <- df[apply(df, 1, function(x) any(is.na(x))),]
  missval <- ifelse(is.na(missval), 0, 1)
  # Plot binary heatmap
  ht2 = Heatmap(missval, col = c("white","black"), column_names_side = "top", show_row_names = F, show_column_names = T,
                name = "Missingness Pattern", column_names_gp = gpar(fontsize = 16))
  draw(ht2, heatmap_legend_side = "top")
}

#' Plot protein numbers
#'
#' \code{plot_numbers} generates a barplot of the number of identified proteins per sample.
#'
#' @param data SummarizedExperiment, Data object for which to plot protein numbers.
#' @return Barplot of the number of identified proteins per sample (generated by \code{\link[ggplot2]{ggplot}})
#' @examples
#' data <- UbiLength
#' data <- filter(data, Reverse != "+", Potential.contaminant != "+")
#' data_unique <- make_unique(data, "Gene.names", "Protein.IDs", delim = ";")
#'
#' columns <- grep("LFQ.", colnames(data_unique))
#' exp_design <- UbiLength_ExpDesign
#' se <- make_se(data_unique, columns, exp_design)
#'
#' filt <- filter_missval(se, thr = 0)
#' plot_numbers(filt)
#' @export
plot_numbers <- function(data) {
  # Show error if input is not the required classes
  assertthat::assert_that(inherits(data, "SummarizedExperiment"))

  # Make a binary long data.frame (1 = valid value, 0 = missing value)
  df <- assay(data) %>% data.frame() %>% rownames_to_column() %>% gather(ID, bin, 2:ncol(.)) %>% mutate(bin = ifelse(is.na(bin), 0, 1))
  # Summarize the number of proteins identified per sample and generate a barplot
  stat <- df %>% group_by(ID) %>% summarize(n = n(), sum = sum(bin)) %>% left_join(., data.frame(colData(data)), by = "ID")
  ggplot(stat, aes(x = ID, y = sum, fill = condition)) + geom_bar(stat = "identity") + geom_hline(yintercept = unique(stat$n)) +
    labs(title = "Proteins per sample", x = "", y = "Number of ProteinGroups") + theme_DEP2()
}

#' Plot protein overlap between samples
#'
#' \code{plot_frequency} generates a barplot of the protein overlap between samples
#'
#' @param data ExpressionSet, Data object for which to plot observation frequency.
#' @return Barplot of overlap of protein identifications between samples (generated by \code{\link[ggplot2]{ggplot}})
#' @examples
#' data <- UbiLength
#' data <- filter(data, Reverse != "+", Potential.contaminant != "+")
#' data_unique <- make_unique(data, "Gene.names", "Protein.IDs", delim = ";")
#'
#' columns <- grep("LFQ.", colnames(data_unique))
#' exp_design <- UbiLength_ExpDesign
#' se <- make_se(data_unique, columns, exp_design)
#'
#' filt <- filter_missval(se, thr = 0)
#' plot_frequency(filt)
#' @export
plot_frequency <- function(data) {
  # Show error if input is not the required classes
  assertthat::assert_that(inherits(data, "SummarizedExperiment"))

  # Make a binary long data.frame (1 = valid value, 0 = missing value)
  df <- assay(data) %>% data.frame() %>% rownames_to_column() %>% gather(ID, bin, 2:ncol(.)) %>% mutate(bin = ifelse(is.na(bin), 0, 1))
  # Identify the number of experiments a protein was observed
  stat <- df %>% group_by(rowname) %>% summarize(sum = sum(bin))
  # Get the frequency of the number of experiments proteins were observerd and plot these numbers
  table <- table(stat$sum) %>% data.frame()
  ggplot(table, aes(x = Var1, y = Freq, fill = Var1)) + geom_bar(stat = "identity") + scale_fill_grey(start = 0.8, end = 0.2) +
    labs(title = "Protein identifications overlap", x = "Identified in number of samples", y = "Number of ProteinGroups") + theme_DEP1()
}

#' Plot protein coverage in conditions
#'
#' \code{plot_coverage} generates a barplot of the protein coverage in samples.
#'
#' @param data ExpressionSet, Data object for which to plot observation frequency.
#' @return Barplot of protein coverage in samples (generated by \code{\link[ggplot2]{ggplot}})
#' @examples
#' data <- UbiLength
#' data <- filter(data, Reverse != "+", Potential.contaminant != "+")
#' data_unique <- make_unique(data, "Gene.names", "Protein.IDs", delim = ";")
#'
#' columns <- grep("LFQ.", colnames(data_unique))
#' exp_design <- UbiLength_ExpDesign
#' se <- make_se(data_unique, columns, exp_design)
#'
#' filt <- filter_missval(se, thr = 0)
#' plot_coverage(filt)
#' @export
plot_coverage <- function(data) {
  # Show error if input is not the required classes
  assertthat::assert_that(inherits(data, "SummarizedExperiment"))

  # Make a binary long data.frame (1 = valid value, 0 = missing value)
  df <- assay(data) %>% data.frame() %>% rownames_to_column() %>% gather(ID, bin, 2:ncol(.)) %>% mutate(bin = ifelse(is.na(bin), 0, 1))
  # Identify the number of experiments a protein was observed
  stat <- df %>% group_by(rowname) %>% summarize(sum = sum(bin))
  # Get the frequency of the number of experiments proteins were observerd and plot the cumulative sum of these numbers
  table <- table(stat$sum) %>% data.frame() %>% mutate(sum = rev(cumsum(rev(Freq))), pos = sum - (Freq / 2))
  ggplot(table, aes(x = "all", y = Freq, fill = Var1)) + geom_col(col = "white") + scale_fill_grey(start = 0.8, end = 0.2) +
    labs(title = "Protein coverage in samples", x = "", y = "Number of ProteinGroups") + guides(fill=guide_legend(title="samples")) +
    theme_DEP1()
}
